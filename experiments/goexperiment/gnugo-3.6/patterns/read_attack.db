# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# This is GNU Go, a Go program. Contact gnugo@gnu.org, or see       #
# http://www.gnu.org/software/gnugo/ for more information.          #
#                                                                   #
# Copyright 1999, 2000, 2001, 2002, 2003 and 2004                   #
# by the Free Software Foundation.                                  #
#                                                                   #
# This program is free software; you can redistribute it and/or     #
# modify it under the terms of the GNU General Public License       #
# as published by the Free Software Foundation - version 2.         #
#                                                                   #
# This program is distributed in the hope that it will be useful,   #
# but WITHOUT ANY WARRANTY; without even the implied warranty of    #
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU #
# General Public License in file COPYING for more details.          #
#                                                                   #
# You should have received a copy of the GNU General Public License #
# along with this program; if not, write to the Free Software       #
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111,  #
# USA.                                                              #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#
#  read_attack.db - pattern database for finding tactical attack moves
#
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# FIXME: Pattern-based reading code is broken.  This makes it even more so.
attribute_map general


# thoughts:
#  Need some way to specify two patterns, one on this end, one on that end.
#  Need some better backfill & superstring helpers.


#### This pattern can break ko-masters, but is not good for much else
##Pattern RA000ko
##
##?XO?	take the ko!
##X*XO
##?XO?
##
##:8,A,value(99)
##



Pattern RA000

O??  geta
.Y?
.X?
*.O

:8,A,value(80)

O??
.Y?
.a?
*.O

; rgoal[a] == 1 &&  lib(a) == 3


Pattern RA000a
# FIXME: May want to add a helper here to test if X playing
# on remaining liberty leaves only one liberty, creating a
# very high value, indeed.

Y*    take a liberty

:-,A,maxvalue(100),minvalue(1)

a*

; rgoal[a] == 1

> {
> int ostar = olib(*);
> int xstar = xlib(*);
> if (lib(a) == 2 && ostar > 1 && xstar >=4)
>   value = 80;
> else if (lib(a) == 2 && ostar > 1 && xstar > 2)
>   value = 72;
> else if (lib(a) == 2 && ostar > 1)
>   value = 70;
> else if ((lib(a) == 1 || xstar > lib(a)+4))
>   value = 97;
> else if (xstar > lib(a)+3 && ostar > 1)
>   value = 96;
> else if (xstar > lib(a)+2 && ostar > 1)
>   value = 95;
> else if (xstar > lib(a)+1 && ostar > 2)
>   value = 64;
> else if (xstar > lib(a)+1 && ostar > 1)
>   value = 63;
> else if (xstar > lib(a)+1  && ostar > 1)
>   value = 62;
> else if (xstar > lib(a) && ostar > 2)
>   value = 61;
> else if (xstar > lib(a) && ostar > 1)
>   value = 60;
> else if (xstar == lib(a)
>	   && ostar > 1
>          && (ostar == xstar || ostar >= lib(a)))
>   value = 60;
> else if (lib(a) == 3 && ostar >= 5)
>   value = 53;
> else if (lib(a) == 3 && ostar >= 4)
>   value = 52;
> else if (lib(a) == 3 && ostar >= 3)
>   value = 51;
> else if (xstar >= lib(a) && ostar > 1)
>   value = 15;
> else
>   value = 2;
>}


Pattern RA001

?x?   throw-in to (maybe) reduce liberties
Y*x
?x?

:8,A,value(45)

?x?
a*x
?x?

; rgoal[a] == 1 && olib(*) == 1


Pattern RA002

.*X  throw-in for better shape
XY?

:8,A,value(71)

b*X
Xa?

; rgoal[a] == 1
; && olib(*) == 1
; && olib(b) == 2
; && xlib(b) <= lib(a)
; && lib(a) == 2


Pattern RA007

Y*   snapback or better
X.

:8,A,minvalue(55),maxvalue(71)

a*
Xb

; rgoal[a] == 1 && xlib(b)==1

> if (goallib() == 2)
>   value = 71;
> else
>   value = 55;


Pattern RA008
# this pattern doesn't really make sense.
# maybe it can be repaired.

X*    atari w/out escape
X.

:8,A,value(68)

a*
ab

; 0 && rgoal[a] == 1 && xlib(b) <= 2 && olib(*) > 1


###################
#Protect boundary:#
###################


Pattern RA101

XQ   capture for liberties
*?

:8,A,minvalue(10), maxvalue(73)

ab
*?

; lib(a) == 1  && lib(b) <=2

> if (goallib() <= lib(b))
>   value = 10;
> else if (!ko(*))
>   value = 73;
> else
>   value = 10;


Pattern RA101a

*XQ   capture for liberties

:8,A,minvalue(10),maxvalue(72)

*ab

; lib(a) == 1  && lib(b) <=2

> if (ko(*))
>   value = 10;
> if (lib(b) >= goallib())
>   value = 60;
> else if (lib(b) == 1)
>   value = 76;
> else
>   value = 72;


Pattern RA102

Q*	extend or connect for liberties

:-,A,minvalue(0),maxvalue(77)

A*

; olib(*) > 1

> {
> int ostar = olib(*);
> if (lib(A) == 1 && ostar >= 3)
>   value = 78;
> else if (lib(A) == 1)
>   value = 72;
> else if (lib(A) == 2 && ostar > 2)
>   /* FIXME: i.e. backfill hack; causes explosion; see reading:35*/
>   value = 10;
> else
>   value = 0;
>}


###########
#backfill #
###########
Pattern RA200

XYO
.O*

:8,A,value(14)

XYO
aO*

;olib(a) == 1


Pattern RA201

YO    backfill
O*

:8,A,value(13)

aO
B*

;rgoal[a] == 1 && lib(B) == 2 && olib(*) >= 2 && xlib(*) >= 2
;&& ((goallib() == 3 && stackp <= backfill2_depth)
;    || (goallib() == 2 && stackp <= backfill_depth))


Pattern RA202
# FIXME: Need a better way to protect border.

QX*   Protect border (maybe with ko)

:-,A,value(50)

Ba*

# FIXME: Taking out to reduce variations
; 0 &&
; rgoal[B] == 2
; && lib(a) <= 2
; && lib(B) <= goallib()
; && (ko(*) || olib(*) > 1)


Pattern RA202a
# FIXME: Need a better way to protect border.

QX   Protect border (maybe with ko)
?*

:8,A,value(50)

Ba
?*

# FIXME: This still looks like a valid pattern, but it breaks
#   reading:26
; 0 && rgoal[B] == 2 && lib(a) <= 2 && lib(B) <= goallib() && (ko(*) || olib(*) > 1)


Pattern RA203
# FIXME: Need a better way to double back

Y.O*   double-back to gain liberties

:-,A,value(50)

acB*

; rgoal[a] == 1 && lib(a) >= olib(c) && olib(*) > lib(B)


Pattern RA203a
# FIXME: Need a better way to double back

Y.O   double-back to gain liberties
??*

:8,A,value(48)

acB
??*

; rgoal[a] == 1 && lib(a) >= olib(c) && olib(*) > lib(B)


#For RA205, see reading:137

Pattern RA205

XQ    back-atari
*.

:8,A,value(35)

ab
*.

; lib(b) < goallib()
; && lib(a) == lib(b)
; && olib(*) >= lib(b)


Pattern RA205a

*XQ    back-atari

:8,A,value(36)

*ab

; lib(b) < goallib()
; && lib(a) == lib(b)
; && olib(*) >= lib(b)


Pattern RA205b

OXQ    back-atari
*X.

:8,A,value(30)

Oab
*X.

; lib(b) < goallib()
; && lib(a) == lib(b)
; && olib(*) >= lib(b)

###############################
#superstring attacks (need to add entire superstring to rgoal?)
################################

Pattern RA300

*X?
?.Y

:8,A,value(59)

*a?
?.Y

;lib(a) == 2 && olib(*) > 1


Pattern RA301

*.    attack superstring
QX

:8,A,value(58)

*b
Qa

; rgoal[a] == 3 && olib(b) <= 1  && olib(*) > 2


Pattern RA302

*Y    attack superstring

:8,A,maxvalue(79)

*a

; (lib(a) <= 3 && olib(*) >= 2)

> if (lib(a) == 2)
>   value = 49;
> else if (lib(a) == 1 && wormsize(a) > 1)
>   value = 79;
> else if (lib(a) == 1)
>   value = 48;
> else if (stackp <= backfill_depth
>          && stackp <= superstring_depth /* || !atari_possible*/)
>   value = 12;
> else
>   value = 0;


Pattern RA303

X*
X.

:8,A,value(50)

X*
ab

; goallib() < lib(a) && lib(a) <=3 && olib(*) >= 2 && xlib(b) <= 4


###########
#draw back#
###########
Pattern RA401

*O
.Y

:8,A,value(49)

*A
bY

;lib(A) <= 3 && olib(b) <= 3 && xlib(*) > 2


#############
# Desperate #
#############


Pattern RA997

X.*    second order liberty

:-,A,minvalue(9),maxvalue(49)

ab*

; rgoal[a] == 1 && goallib() < 3

> if (olib(b) <= 1)
>   value = 49;
> else
>   value = 9;


Pattern RA998

X.    diagonal liberty
?*

:8,A,minvalue(9),maxvalue(49)

ab
?*

# Too many variations.
; rgoal[a] == 1

> if (olib(b) <= 1)
>   value = 49;
> else
>   value = 0;


Pattern RA999

X.    find_cap2
.*

:8,A,value(25)

a.
.*

; rgoal[a] == 1

