This is gnugo.info, produced by makeinfo version 4.11 from gnugo.texi.

INFO-DIR-SECTION GNU games
START-INFO-DIR-ENTRY
* GNU Go: (gnugo).          The GNU Go program
END-INFO-DIR-ENTRY


File: gnugo.info,  Node: Another Ko Example,  Next: Alternate Komaster Schemes,  Prev: A Ko Example,  Up: Tactical Reading

11.6 Another Ko Example
=======================

We now consider an example to show why the komaster is reset to `EMPTY'
if the ko is resolved in the komaster's favor. This means that the ko
is filled, or else that is becomes no longer a ko and it is illegal for
the komaster's opponent to play there.

   The position resulting under consideration is in the file
`regressions/games/ko5.sgf'.  This is the position:

      . . . . . . O O 8
      X X X . . . O . 7
      X . X X . . O . 6
      . X . X X X O O 5
      X X . X . X O X 4
      . O X O O O X . 3
      O O X O . O X X 2
      . O . X O X X . 1
      F G H J K L M N

   We recommend studying this example by examining the variation file
produced by the command:

     gnugo -l ko5.sgf --quiet --decide-string L1 -o vars.sgf

   The correct resolution is that H1 attacks L1 unconditionally while K2
defends it with ko (code `KO_A').

   After Black (X) takes the ko at K3, white can do nothing but retake
the ko conditionally, becoming komaster. B cannot do much, but in one
variation he plays at K4 and W takes at H1. The following position
results:

      . . . . . . O O 8
      X X X . . . O . 7
      X . X X . . O . 6
      . X . X X X O O 5
      X X . X X X O X 4
      . O X O O O X . 3
      O O X O . O X X 2
      . O O . O X X . 1
      F G H J K L M N

   Now it is important the `O' is no longer komaster. Were `O' still
komaster, he could capture the ko at N3 and there would be no way to
finish off B.


File: gnugo.info,  Node: Alternate Komaster Schemes,  Next: Superstrings,  Prev: Another Ko Example,  Up: Tactical Reading

11.7 Alternate Komaster Schemes
===============================

The following alternate schemes have been proposed. It is assumed that
`O' is the player about to move.

11.7.1 Essentially the 2.7.232 scheme.
--------------------------------------

   * Komaster is EMPTY.
        - Unconditional ko capture is allowed. Komaster remains EMPTY.

        - Conditional ko capture is allowed. Komaster is set to O and
          `kom_pos' to the location of the ko, where a stone was just
          removed.

   * Komaster is O:
        - Conditional ko capture is not allowed.

        - Unconditional ko capture is allowed. Komaster parameters
          unchanged.

   * Komaster is X:
        - Conditional ko capture is not allowed.

        - Unconditional ko capture is allowed except for a move at
          `kom_pos'. Komaster parameters unchanged.

11.7.2 Revised 2.7.232 version
------------------------------

   * Komaster is EMPTY.
        - Unconditional ko capture is allowed. Komaster remains EMPTY.

        - Conditional ko capture is allowed. Komaster is set to `O' and
          `kom_pos' to the location of the ko, where a stone was just
          removed.

   * Komaster is `O':
        - Ko capture (both kinds) is allowed only if after playing the
          move, `is_ko(kom_pos, X)' returns false. In that case,
          `kom_pos' is updated to the new ko position, i.e. the stone
          captured by this move.

   * Komaster is `X':
        - Conditional ko capture is not allowed.

        - Unconditional ko capture is allowed except for a move at
          `kom_pos'. Komaster parameters unchanged.


File: gnugo.info,  Node: Superstrings,  Next: Debugging,  Prev: Alternate Komaster Schemes,  Up: Tactical Reading

11.8 Superstrings
=================

A _superstring_ is an extended string, where the extensions are through
the following kinds of connections:

  1. Solid connections (just like ordinary string).
            OO

  2. Diagonal connection or one space jump through an intersection
     where an opponent move would be suicide or self-atari.
            ...
            O.O
            XOX
            X.X

  3. Bamboo joint.
            OO
            ..
            OO

  4. Diagonal connection where both adjacent intersections are empty.
            .O
            O.

  5. Connection through adjacent or diagonal tactically captured stones.
     Connections of this type are omitted when the superstring code is
     called from `reading.c', but included when the superstring code is
     called from `owl.c'.

   Like a dragon, a superstring is an amalgamation of strings, but it is
a much tighter organization of stones than a dragon, and its purpose is
different. Superstrings are encountered already in the tactical reading
because sometimes attacking or defending an element of the superstring
is the best way to attack or defend a string. This is in contrast with
dragons, which are ignored during tactical reading.


File: gnugo.info,  Node: Debugging,  Next: Connection Reading,  Prev: Superstrings,  Up: Tactical Reading

11.9 Debugging the reading code
===============================

The reading code searches for a path through the move tree to determine
whether a string can be captured. We have a tool for investigating this
with the `--decidestring' option. This may be run with or without an
output file.

   Simply running


     `gnugo -t -l [input file name] -L [movenumber] --decidestring [location]'

will run `attack()' to determine whether the string can be captured.
If it can, it will also run `find_defense()' to determine whether or
not it can be defended. It will give a count of the number of
variations read. The `-t' is necessary, or else GNU Go will not report
its findings.

   If we add `-o OUTPUT FILE' GNU Go will produce an output file with
all variations considered. The variations are numbered in comments.

   This file of variations is not very useful without a way of
navigating the source code. This is provided with the GDB source file,
listed at the end. You can source this from GDB, or just make it your
GDB init file.

   If you are using GDB to debug GNU Go you may find it less confusing
to compile without optimization. The optimization sometimes changes the
order in which program steps are executed. For example, to compile
`reading.c' without optimization, edit `engine/Makefile' to remove the
string `-O2' from the file, touch `engine/reading.c' and make. Note
that the Makefile is automatically generated and may get overwritten
later.

   If in the course of reading you need to analyze a result where a
function gets its value by returning a cached position from the hashing
code, rerun the example with the hashing turned off by the command line
option `--hash 0'. You should get the same result. (If you do not,
please send us a bug report.) Don't run `--hash 0' unless you have a
good reason to, since it increases the number of variations.

   With the source file given at the end of this document loaded, we
can now navigate the variations. It is a good idea to use cgoban with a
small `-fontHeight', so that the variation window takes in a big
picture. (You can resize the board.)

   Suppose after perusing this file, we find that variation 17 is
interesting and we would like to find out exactly what is going on here.

   The macro 'jt n' will jump to the n-th variation.


     (gdb) set args -l [filename] -L [move number] --decidestring [location]
     (gdb) tbreak main
     (gdb) run
     (gdb) jt 17

will then jump to the location in question.

   Actually the attack variations and defense variations are numbered
separately. (But `find_defense()' is only run if `attack()' succeeds,
so the defense variations may or may not exist.) It is redundant to
have to tbreak main each time. So there are two macros avar and dvar.


     (gdb) avar 17

restarts the program, and jumps to the 17-th attack variation.


     (gdb) dvar 17

jumps to the 17-th defense variation. Both variation sets are found in
the same sgf file, though they are numbered separately.

   Other commands defined in this file:



     `dump' will print the move stack.
     `nv' moves to the next variation
     `ascii i j' converts (i,j) to ascii

     #######################################################
     ###############      .gdbinit file      ###############
     #######################################################

     # this command displays the stack

     define dump
     set dump_stack()
     end

     # display the name of the move in ascii

     define ascii
     set gprintf("%o%m\n",$arg0,$arg1)
     end

     # display the all information about a dragon

     define dragon
     set ascii_report_dragon("$arg0")
     end

     define worm
     set ascii_report_worm("$arg0")
     end

     # move to the next variation

     define nv
     tbreak trymove
     continue
     finish
     next
     end

     # move forward to a particular variation

     define jt
     while (count_variations < $arg0)
     nv
     end
     nv
     dump
     end

     # restart, jump to a particular attack variation

     define avar
     delete
     tbreak sgffile_decidestring
     run
     tbreak attack
     continue
     jt $arg0
     end

     # restart, jump to a particular defense variation

     define dvar
     delete
     tbreak sgffile_decidestring
     run
     tbreak attack
     continue
     finish
     next 3
     jt $arg0
     end


File: gnugo.info,  Node: Connection Reading,  Prev: Debugging,  Up: Tactical Reading

11.10 Connection Reading
========================

GNU Go does reading to determine if strings can be connected.  The
algorithms for this are in `readconnect.c'. As with the reading code,
the connection code is not pattern based.

   The connection code is invoked by the engine through the functions:

   * `int string_connect(int str1, int str2, int *move)' 

          Returns `WIN' if `str1' and `str2' can be connected.

   * `int disconnect(int str1, int str2, int *move)' 

          Returns `WIN' if `str1' and `str2' can be disconnected.

   To see the connection code in action, you may try the following
example.

     gnugo --quiet -l connection3.sgf --decide-connection M3/N7 -o vars.sgf

   (The file `connection3.sgf' is in `regression/games'.)  Examine the
sgf file produced by this to see what kind of reading is done by the
functions `string_connect()' and `string_disconnect()', which are
called by the function `decide_connection'.

   One use of the connection code is used is through the autohelper
macros `oplay_connect', `xplay_connect', `oplay_disconnect' and
`xplay_disconnect' which are used in the connection databases.


File: gnugo.info,  Node: Pattern Based Reading,  Next: Influence,  Prev: Tactical Reading,  Up: Top

12 Pattern Based Reading
************************

In the tactical reading code in `reading.c', the code generating the
moves which are tried are all hand coded in C, for efficiency. There is
much to be said for another type of reading, in which the moves to be
tried are generated from a pattern database.

   GNU Go does three main types of pattern based reading. First, there
is the OWL code (Optics with Limit Negotiation) which attempts to read
out to a point where the code in `engine/optics.c' (*note Eyes::) can
be used to evaluate it.  Like the tactical reading code, a persistent
cache is employed to maintain some of the owl data from move to move.
This is an essential speedup without which GNU Go would play too slowly.

   Secondly, there is the `engine/combination.c' which attempts to find
combinations--situations where a series of threats eventually
culminates in one that cannot be parried.

   Finally there is the semeai module. A *semeai* is a capturing race
between two adjacent DEAD or CRITICAL dragons of opposite colors. The
principal function, `owl_analyze_semeai()' is contained in `owl.c'.
Due to the complex nature of semeais, the results of this function are
more frequently wrong than the usual owl code.

* Menu:

* The Owl Code::                Life and death reading
* Combinations::                Combinations


File: gnugo.info,  Node: The Owl Code,  Next: Combinations,  Up: Pattern Based Reading

12.1 The Owl Code
=================

The life and death code in `optics.c', described elsewhere (*note
Eyes::), works reasonably well as long as the position is in a
"terminal position", which we define to be one where there are no moves
left which can expand the eye space, or limit it. In situations where
the dragon is surrounded, yet has room to thrash around a bit making
eyes, a simple application of the graph-based analysis will not work.
Instead, a bit of reading is needed to reach a terminal position.

   The defender tries to expand his eyespace, the attacker to limit it,
and when neither finds an effective move, the position is evaluated. We
call this type of life and death reading "Optics With
Limit-negotiation" (OWL). The module which implements it is in
`engine/owl.c'.

   There are two reasonably small databases
`patterns/owl_defendpats.db' and `patterns/owl_attackpats.db' of
expanding and limiting moves. The code in `owl.c' generates a small
move tree, allowing the attacker only moves from `owl_attackpats.db',
and the defender only moves from `owl_defendpats.db'. In addition to
the moves suggested by patterns, vital moves from the eye space
analysis are also tested.

   A third database, `owl_vital_apats.db' includes patterns which
override the eyespace analysis done by the optics code. Since the
eyeshape graphs ignore the complications of shortage of liberties and
cutting points in the surrounding chains, the static analysis of
eyespace is sometimes wrong. The problem is when the optics code says
that a dragon definitely has 2 eyes, but it isn't true due to shortage
of liberties, so the ordinary owl patterns never get into play.  In
such situations `owl_vital_apats.db' is the only available measure to
correct mistakes by the optics. Currently the patterns in
`owl_vital_apats.db' are only matched when the level is 9 or greater.

   The owl code is tuned by editing these three pattern databases,
principally the first two.

   A node of the move tree is considered `terminal' if no further moves
are found from `owl_attackpats.db' or `owl_defendpats.db', or if the
function `compute_eyes_pessimistic()' reports that the group is
definitely alive. At this point, the status of the group is evaluated.
The functions `owl_attack()' and `owl_defend()', with usage similar to
`attack()' and `find_defense()', make use of the owl pattern databases
to generate the move tree and decide the status of the group.

   The function `compute_eyes_pessimistic()' used by the owl code is
very conservative and only feels certain about eyes if the eyespace is
completely closed (i.e. no marginal vertices).

   The maximum number of moves tried at each node is limited by the
parameter `MAX_MOVES' defined at the beginning of `engine/owl.c'. The
most most valuable moves are tried first, with the following
restrictions:

   * If `stackp > owl_branch_depth' then only one move is tried per
     variation.

   * If `stackp > owl_reading_depth' then the reading terminates, and
     the situation is declared a win for the defender (since deep
     reading may be a sign of escape).

   * If the node count exceeds `owl_node_limit', the reading also
     terminates with a win for the defender.

   * Any pattern with value 99 is considered a forced move: no other
     move is tried, and if two such moves are found, the function
     returns false. This is only relevant for the attacker.

   * Any pattern in `patterns/owl_attackpats.db' and
     `patterns/owl_defendpats.db' with value 100 is considered a win: if
     such a pattern is found by `owl_attack' or `owl_defend', the
     function returns true. This feature must be used most carefully.

   The functions `owl_attack()' and `owl_defend()' may, like `attack()'
and `find_defense()', return an attacking or defending move through
their pointer arguments. If the position is already won, `owl_attack()'
may or may not return an attacking move. If it finds no move of
interest, it will return `PASS', that is, `0'. The same goes for
`owl_defend()'.

   When `owl_attack()' or `owl_defend()' is called, the dragon under
attack is marked in the array `goal'.  The stones of the dragon
originally on the board are marked with goal=1; those added by
`owl_defend()' are marked with goal=2. If all the original strings of
the original dragon are captured, `owl_attack()' considers the dragon
to be defeated, even if some stones added later can make a live group.

   Only dragons with small escape route are studied when the functions
are called from `make_dragons()'.

   The owl code can be conveniently tested using the `--decide-owl
LOCATION' option. This should be used with `-t' to produce a useful
trace, `-o' to produce an SGF file of variations produced when the life
and death of the dragon at LOCATION is checked, or both.
`--decide-position' performs the same analysis for all dragons with
small escape route.


File: gnugo.info,  Node: Combinations,  Prev: The Owl Code,  Up: Pattern Based Reading

12.2 Combination reading
========================

It may happen that no single one of a set of worms can be killed, yet
there is a move that guarantees that at least one can be captured.  The
simplest example is a double atari.  The purpose of the code in
`combination.c' is to find such moves.

   For example, consider the following situation:


     +---------
     |....OOOOX
     |....OOXXX
     |..O.OXX..
     |.OXO.OX..
     |.OX..OO..
     |.XXOOOXO.
     |..*XXOX..
     |....XOX..
     |.XX..X...
     |X........

   Every `X' stone in this position is alive. However the move at `*'
produces a position in which at least one of four strings will get
captured. This is a _combination_.

   The driving function is called `atari_atari' because typically a
combination involves a sequence of ataris culminating in a capture,
though sometimes the moves involved are not ataris. For example in the
above example, the first move at `*' is _not_ an atari, though after
`O' defends the four stones above, a sequence of ataris ensues
resulting in the capture of some string.

   Like the owl functions `atari_atari' does pattern-based reading. The
database generating the attacking moves is `aa_attackpats.db'. One
danger with this function is that the first atari tried might be
irrelevant to the actual combination.  To detect this possibility, once
we've found a combination, we mark that first move as forbidden, then
try again. If no combination of the same size or larger turns up, then
the first move was indeed essential.

   * `void combinations(int color)' 

          Generate move reasons for combination attacks and defenses
          against them. This is one of the move generators called from
          genmove().

   * `int atari_atari(int color, int *attack_move, char
     defense_moves[BOARDMAX], int save_verbose)' 

          Look for a combination for `color'. For the purpose of the
          move generation, returns the size of the smallest of the
          worms under attack.

   * `int atari_atari_confirm_safety(int color, int move, int *defense,
     int minsize, const char saved_dragons[BOARDMAX], const char
     saved_worms[BOARDMAX])' 

          Tries to determine whether a move is a blunder.  Wrapper
          around atari_atari_blunder_size. Check whether a combination
          attack of size at least `minsize' appears after move at
          `move' has been made.  The arrays `saved_dragons[]' and
          `saved_worms[]' should be one for stones belonging to dragons
          or worms respectively, which are supposedly saved by `move'.

   * `int atari_atari_blunder_size(int color, int move, int *defense,
     const char safe_stones[BOARDMAX])' 

          This function checks whether any new combination attack
          appears after move at (move) has been made, and returns its
          size (in points).  `safe_stones' marks which of our stones
          are supposedly safe after this move.


File: gnugo.info,  Node: Influence,  Next: Alternative Moyo,  Prev: Pattern Based Reading,  Up: Top

13 Influence Function
*********************

* Menu:

* Influential Concepts::        Conceptual Outline of Influence
* Territory and Moyo::		Territory, Moyo and Area
* Influence Usage::		Where influence gets used in the engine
* Influence and Territory::     Influence and Territory
* Territorial Details::		Details of the Territory Valuation
* The Influence Core::          The Core of the Influence Function
* The Influence Algorithm::     The algorithm of `accumlate_influence()'
* Permeability::                Permeability
* Escape::                      Escape
* Break Ins::                   Break Ins
* Surrounded Dragons::          Surrounded Dragons
* Influential Patterns::	Patterns used by the Influence module
* Influential Display::         Colored display and debugging of influence
* Influence Tuning::            Influence tuning with view.pike


File: gnugo.info,  Node: Influential Concepts,  Next: Territory and Moyo,  Up: Influence

13.1 Conceptual Outline of Influence
====================================

We define call stones "lively" if they cannot be tactically attacked,
or if they have a tactical defense and belong to the player whose turn
it is. Similarly, stones that cannot be strategically attacked (in the
sense of the life-and-death analysis), or that have a strategical
defense and belong to the player to move, are called "alive".  If we
want to use the influence function before deciding the strategical
status, all lively stones count as alive.

   Every alive stone on the board works as an influence source, with
influence of its color radiating outwards in all directions. The
strength of the influence declines exponentially with the distance from
the source.

   Influence can only flow unhindered if the board is empty, however.
All lively stones (regardless of color) act as influence barriers, as do
connections between enemy stones that can't be broken through. For
example the one space jump counts as a barrier unless either of the
stones can be captured. Notice that it doesn't matter much if the
connection between the two stones can be broken, since in that case
there would come influence from both directions anyway.

   From the influence of both colors we compute a territorial value
between -1.0 and +1.0 for each intersection, which can be seen as the
likely hood of it becoming territory for either color.

   In order to avoid finding bogus territory, we add extra influence
sources at places where an invasion can be launched, e.g. at 3-3 under
a handicap stone, in the middle of wide edge extensions and in the
center of large open spaces anywhere. Similarly we add extra influence
sources where intrusions can be made into what otherwise looks as solid
territory, e.g. monkey jumps. These intrusions depend on whose turn we
assume it to be.

   All these extra influence sources, as well as connections, are
controlled by a pattern database, which consists of the two files
patterns/influence.db and patterns/barriers.db. The details are
explained in *note Influential Patterns::.


File: gnugo.info,  Node: Territory and Moyo,  Next: Influence Usage,  Prev: Influential Concepts,  Up: Influence

13.2 Territory, Moyo and Area
=============================

Using the influence code, empty regions of the board are partitioned in
three ways. A vertex may be described as White or Black's "territory",
"moyo" or "area". The functions `whose_territory()', `whose_moyo()' and
`whose_area()' will return a color, or EMPTY if it belongs to one
player or the other in one of these classifications.

   * Territory

          Those parts of the board which are expected to materialize as
          actual points for one player or the other at the end of the
          game are considered "territory".

   * Moyo

          Those parts of the board which are either already territory
          or more generally places where a territory can easily
          materialize if the opponent neglects to reduce are considered
          "moyo".  "moyo".

   * Area

          Those parts of the board where one player or the other has a
          stronger influence than his opponent are considered "area".

   Generally territory is moyo and moyo is area. To get a feeling for
these concepts, load an sgf file in a middle game position with the
option `-m 0x0180' and examine the resulting diagrams (*note
Influential Display::).


File: gnugo.info,  Node: Influence Usage,  Next: Influence and Territory,  Prev: Territory and Moyo,  Up: Influence

13.3 Where influence gets used in the engine
============================================

The information obtained from the influence computation is used in a
variety of places in the engine, and the influence module is called
several times in the process of the move generation. The details of the
influence computation vary according to the needs of the calling
function.

   After GNU Go has decided about the tactical stability of strings, the
influence module gets called the first time. Here all lively stones act
as an influence source of default strength 100. The result is stored in
the variables `initial_influence' and `initial_opposite_influence', and
it is used as an important information for guessing the strength of
dragons. For example, a dragon that is part of a moyo of size 25 is
immediately considered alive.  For dragons with a smaller moyo size, a
life-and-death analysis will be done by the owl code (see *note Pattern
Based Reading::). A dragon with a moyo size of only 5 will be
considered weak, even if the owl code has decided that it cannot be
killed.

   As a tool for both the owl code and the strength estimate of dragons,
an "escape" influence gets computed for each dragon (*note Escape::).

   Once all dragons have been evaluated, the influence module is called
again and the variables `initial_influence' and
`initial_opposite_influence' get overwritten. Of course, the dragon
status', which are available now, are taken into account. Stones
belonging to a dead dragon will not serve as an influence source, and
the strengths of other stones get adjusted according to the strength of
their respective dragon.

   The result of this run is the most important tool for move
evaluation. All helper functions of patterns as explained in *note
Patterns:: that refer to influence results (e. g. `olib(*)' etc.)
actually use these results. Further, `initial_influence' serves as the
reference for computing the territorial value of a move. That is, from
the influence strengths stored in `initial_influence', a territory
value is assigned to each intersection. This value is supposed to
estimate the likelyhood that this intersection will become white or
black territory.

   Then, for each move that gets considered in the function
`value_moves', the influence module is called again via the function
`compute_move_influence' to assess the likely territorial balance after
this move, and the result is compared with the state before that move.

   An additional influence computation is done in order to compute the
followup value of a move. Some explainations are in *note Territorial
Details::.

   Some of the public functions from `influence.c' which are used
throughout the engine are listed in *note Influence Utilities::.


File: gnugo.info,  Node: Influence and Territory,  Next: Territorial Details,  Prev: Influence Usage,  Up: Influence

13.4 Influence and Territory
============================

In this section we consider how the influence function is used to
estimate territory in the function `estimate_territorial_value()'.

   A move like `*' by `O' below is worth one point:

     OXXX.
     OX.XX
     O*a.X
     OX.XX
     OXXX.

   This is evaluated by the influence function in the following way: We
first assign territory under the assumption that X moves first in all
local positions in the original position;  then we reassing territory,
again under the assumption that `X' moves first in all local positions,
but after we let `O' make the move at `*'. These two territory
assignments are compared and the difference gives the territorial value
of the move.

   Technically, the assumption that `X' plays first everywhere is
implemented via an asymmetric pattern database in `barriers.db'.  What
exactly is a safe connection that stops hostile influence from passing
through is different for `O' and `X'; of course such a connection has
to be tighter for stones with color `O'. Also, additional intrusion
influence sources are added for `X' in places where `X' stones have
natural followup moves.

   In this specific example above, the asymmetry (before any move has
been made) would turn out as follows: If `X' is in turn to move, the
white influence would get stopped by a barrier at `*', leaving 4 points
of territory for `X'.  However, if `O' was next to move, then a
followup move for the white stones at the left would be assumed in the
form of an extra ("intrusion") influence source at `*'. This would get
stopped at `a', leaving three points of territory.

   Returning to the valuation of a move by `O' at `*', we get a value
of 1 for the move at `*'.  However, of course this move is sente once
it is worth playing, and should therefore (in miai counting) be awarded
an effective value of 2. Hence we need to recognize the followup value
of a move. GNU Go 3.0 took care of this by using patterns in
`patterns.db' that enforced an explicit followup value. Versions from
3.2 on instead compute a seperate followup influence to each move
considered. In the above example, an intrusion source will be added at
`a' as a followup move to `*'. This destroys all of Black's territory
and hence gives a followup value of 3.

   The pattern based followup value are still needed at some places,
however.

   To give another example, consider this position where we want to
estimate the value of an `O' move at `*':

     OOOXXX
     ..OX..
     ..OX..
     ...*..
     ------

   Before the move we assume `X' moves first in the local position (and
that `O' has to connect), which gives territory like this (lower case
letter identify territory for each player):

     OOOXXX
     ooOXxx
     o.OXxx
     o...xx
     ------

   Then we let `O' make the move at `*' and assume `X' moves first
again next.  The territory then becomes (`X' is also assumed to have to
connect):

     OOOXXX
     ooOXxx
     ooOX.x
     oo.O.x
     ------

   We see that this makes a difference in territory of 4, which is what
influence_delta_territory() should report. Then again, we have followup
value, and here also a reverse followup value. The reverse followup
value, which in this case will be so high that the move is treated as
reverse sente, is added by an explicit pattern. Other sources for
followup or reverse followup values are threats to capture a rescue a
string of stones.  See the code and comments in the function
`value_move_reaons' for how followup and reverse followup values are
used to adjust the effective move value.

   To give an example of territorial value where something is captured,
consider the `O' move at `*' here,

     XXXXXXXO
     X.OOOOXO
     X.O..O*O
     --------

   As before we first let the influence function determine territory
assuming X moves first, i.e. with a captured group:

     XXXXXXXO
     XxyyyyXO
     Xxyxxy.O
     --------

   Here `y' indicates `X' territory + captured stone, i.e. these count
for two points. After the `O' move at `*' we instead get

     XXXXXXXO
     X.OOOOXO
     X.OooOOO
     --------

   and we see that `X' has 16 territory fewer and `O' has two territory
more, for a total difference of 18 points.

   That the influence function counts the value of captured stones was
introduced in GNU Go 3.2. Previously this was instead done using the
effective_size heuristic. The effective size is the number of stones
plus the surrounding empty spaces which are closer to this string or
dragon than to any other stones. Here the `O' string would thus have
effective size 6 (number of stones) + 2 (interior eye) + 2*0.5 (the two
empty vertices to the left of the string, split half each with the
surrounding X string) + 1*0.33 (the connection point, split between
three strings) = 9.33. As noted this value was doubled, giving 18.67
which is reasonably close to the correct value of 18. The effective size
heuristic is still used in certain parts of the move valuation where we
can't easily get a more accurate value from the influence function (e.
g. attacks depending on a ko, attack threats).

   Note that this section only describes the territorial valuation of a
move.  Apart from that, GNU Go uses various heuristics in assigning a
strategical value (weakening and strengthening of other stones on the
board) to a move.  Also, the influence function isn't quite as well
tuned as the examples above may seem to claim. But it should give a
fairly good idea of how the design is intended.

   Another matter is that so far we have only considered the change in
secure territory. GNU Go 3.2 and later versions use a revised
heuristic, which is explained in the next section, to assign probable
territory to each player.


File: gnugo.info,  Node: Territorial Details,  Next: The Influence Core,  Prev: Influence and Territory,  Up: Influence

13.5 Details of the Territory Valuation
=======================================

This section explains how GNU Go assigns a territorial value to an
intersection once the white and black influence have been computed.
The intention is that an intersection that has a chance of xx% of
becoming white territory is counted as 0.xx points of territory for
white, and similar for black.

   The algorithm in the function `new_value_territory' goes roughly as
follows:

   If `wi' is the white influence at a point, and `bi' the black
influence, then ` value = ( (wi-bi)/ (wi+bi) )^3' (positive values
indicates likley white territory, negative stand for black territory)
turns out to be very simple first guess that is still far off, but
reasonable enough to be useful.

   This value is then suspect a number of corrections. Assume that this
first guess resulted in a positive value.

   If both `bi' and `wi' are small, it gets reduced. What exactly is
"small" depends on whether the intersection is close to a corner or an
edge of the board, since it is easier to claim territory in the corner
than in the center.

   Then the value at each intersection is degraded to the minimum value
of its neighbors. This can be seen as a second implementation of the
proverb saying that there is no territory in the center of the board.
This step substantially reduces the size of spheres of territory that
are open at several sides.

   Finally, there are a number of patterns that explicitly forbid GNU
Go to count territory at some intersections. This is used e. g. for
false eyes that will eventually have to be filled in. Also, points for
prisoners are added.

   To fine tune this scheme, some revisions have been made to the
influence computations that are relevant for territorial evaluation.
This includes a reduced default attenuation and some revised pattern
handling.


File: gnugo.info,  Node: The Influence Core,  Next: The Influence Algorithm,  Prev: Territorial Details,  Up: Influence

13.6 The Core of the Influence Function
=======================================

The basic influence radiation process can efficiently be implemented as
a breadth first search for adjacent and more distant points, using a
queue structure.

   Influence barriers can be found by pattern matching, assisted by
reading through constraints and/or helpers. Wall structures, invasion
points and intrusion points can be found by pattern matching as well.

   When influence is computed, the basic idea is that there are a number
of influence sources on the board, whose contributions are summed to
produce the influence values. For the time being we can assume that the
living stones on the board are the influence sources, although this is
not the whole story.

   The function `compute_influence()' contains a loop over the board,
and for each influence source on the board, the function
`accumulate_influence()' is called. This is the core of the influence
function. Before we get into the details, this is how the influence
field from a single isolated influence source of strength 100 turns out
(with an attenuation of 3.0):

       0  0  0  0  0  0  0  0  0  0  0
       0  0  0  0  1  1  1  0  0  0  0
       0  0  0  1  2  3  2  1  0  0  0
       0  0  1  3  5 11  5  3  1  0  0
       0  1  2  5 16 33 16  5  2  1  0
       0  1  3 11 33  X 33 11  3  1  0
       0  1  2  5 16 33 16  5  2  1  0
       0  0  1  3  5 11  5  3  1  0  0
       0  0  0  1  2  3  2  1  0  0  0
       0  0  0  0  1  1  1  0  0  0  0
       0  0  0  0  0  0  0  0  0  0  0

   These values are in reality floating point numbers but have been
rounded down to the nearest integer for presentation. This means that
the influence field does not stop when the numbers become zeroes.

   Internally `accumulate_influence()' starts at the influence source
and spreads influence outwards by means of a breadth first propagation,
implemented in the form of a queue. The order of propagation and the
condition that influence only is spread outwards guarantee that no
intersection is visited more than once and that the process terminates.
In the example above, the intersections are visited in the following
order:

       +  +  +  +  +  +  +  +  +  +  +
       + 78 68 66 64 63 65 67 69 79  +
       + 62 46 38 36 35 37 39 47 75  +
       + 60 34 22 16 15 17 23 43 73  +
       + 58 32 14  6  3  7 19 41 71  +
       + 56 30 12  2  0  4 18 40 70  +
       + 57 31 13  5  1  8 20 42 72  +
       + 59 33 21 10  9 11 24 44 74  +
       + 61 45 28 26 25 27 29 48 76  +
       + 77 54 52 50 49 51 53 55 80  +
       +  +  +  +  +  +  +  +  +  +  +

   The visitation of intersections continues in the same way on the
intersections marked '`+' and further outwards. In a real position
there will be stones and tight connections stopping the influence from
spreading to certain intersections. This will disrupt the diagram
above, but the main property of the propagation still remains, i.e. no
intersection is visited more than once and after being visited no more
influence will be propagated to the intersection.


File: gnugo.info,  Node: The Influence Algorithm,  Next: Permeability,  Prev: The Influence Core,  Up: Influence

13.7 The Influence Algorithm
============================

Let `(m, n)' be the coordinates of the influence source and `(i, j)'
the coordinates of a an intersection being visited during propagation,
using the same notation as in the `accumulate_influence()' function.
Influence is now propagated to its eight closest neighbors, including
the diagonal ones, according to the follow scheme:

   For each of the eight directions `(di, dj)', do:

  1. Compute the scalar product `di*(i-m) + dj*(j-n)' between the
     vectors `(di,dj)' and `(i,j) - (m,n)'

  2. If this is negative or zero, the direction is not outwards and we
     continue with the next direction. The exception is when we are
     visiting the influence source, i.e. the first intersection, when
     we spread influence in all directions anyway.

  3. If `(i+di, j+dj)' is outside the board or occupied we also
     continue with the next direction.

  4. Let S be the strength of the influence at `(i, j)'. The influence
     propagated to `(i+di, j+dj)' from this intersection is given by
     `P*(1/A)*D*S', where the three different kinds of damping are:

        * The permeability `P', which is a property of the board
          intersections. Normally this is one, i.e. unrestricted
          propagation, but to stop propagation through e.g. one step
          jumps, the permeability is set to zero at such intersections
          through pattern matching. This is further discussed below.

        * The attenuation `A', which is a property of the influence
          source and different in different directions. By default this
          has the value 3 except diagonally where the number is twice
          as much. By modifying the attenuation value it is possible to
          obtain influence sources with a larger or a smaller effective
          range.

        * The directional damping `D', which is the squared cosine of
          the angle between `(di,dj)' and `(i,j) - (m,n)'. The idea is
          to stop influence from "bending" around an interfering stone
          and get a continuous behavior at the right angle cutoff. The
          choice of the squared cosine for this purpose is rather
          arbitrary, but has the advantage that it can be expressed as a
          rational function of `m', `n', `i', `j', `di', and `dj',
          without involving any trigonometric or square root
          computations. When we are visiting the influence source we
          let by convention this factor be one.

   Influence is typically contributed from up to three neighbors
"between" this intersection and the influence source. These values are
simply added together. As pointed out before, all contributions will
automatically have been made before the intersection itself is visited.

   When the total influence for the whole board is computed by
`compute_influence()', `accumulate_influence()' is called once for each
influence source. These invocations are totally independent and the
influence contributions from the different sources are added together.


File: gnugo.info,  Node: Permeability,  Next: Escape,  Prev: The Influence Algorithm,  Up: Influence

13.8 Permeability
=================

The permeability at the different points is initially one at all empty
intersections and zero at occupied intersections. To get a useful
influence function we need to modify this, however. Consider the
following position:

     |......
     |OOOO..
     |...O..
     |...a.X   ('a' empty intersection)
     |...O..
     |...OOO
     |.....O
     +------

   The corner is of course secure territory for `O' and clearly the `X'
stone has negligible effect inside this position. To stop `X' influence
from leaking into the corner we use pattern matching (pattern
Barrier1/Barrier2 in `barriers.db') to modify the permeability for `X'
at this intersection to zero. `O' can still spread influence through
this connection.

   Another case that needs to be mentioned is how the permeability
damping is computed for diagonal influence radiation. For horizontal
and vertical radiation we just use the permeability (for the relevant
color) at the intersection we are radiating from. In the diagonal case
we additionally multiply with the maximum permeability at the two
intersections we are trying to squeeze between. The reason for this can
be found in the diagram below:

     |...X    |...X
     |OO..    |Oda.
     |..O.    |.bc.
     |..O.    |..O.
     +----    +----

   We don't want `X' influence to be spread from `a' to `b', and since
the permeability at both c and d is zero, the rule above stops this.


File: gnugo.info,  Node: Escape,  Next: Break Ins,  Prev: Permeability,  Up: Influence

13.9 Escape
===========

One application of the influence code is in computing the
`dragon.escape_route' field. This is computed by the function
`compute_escape()' as follows.  First, every intersection is assigned
an escape value, ranging between 0 and 4, depending on the influence
value of the opposite color.

   The `escape_route' field is modified by the code in `surround.c'
(*note Surrounded Dragons::). It is divided by two for weakly surrounded
dragons, and set to zero for surrounded ones.

   In addition to assiging an escape value to empty vertices, we also
assign an escape value to friendly dragons. This value can range from 0
to 6 depending on the status of the dragon, with live dragons having
value 6.

   Then we sum the values of the resulting influence escape values over
the intersections (including friendly dragons) at distance 4, that is,
over those intersections which can be joined to the dragon by a path of
length 4 (and no shorter path) not passing adjacent to any unfriendly
dragon. In the following example, we sum the influence escape value
over the four vertices labelled '4'.


        . . . . . . . . .    . . . . . . . . .
        . . . . . X . . O    . . . . . X . . O
        . . X . . . . . O    . . X . 2 . 4 . O
        X . . . . . . . .    X . . 1 1 2 3 4 .
        X O . O . . . . O    X O 1 O 1 2 3 4 O
        X O . O . . . . .    X O 1 O 1 . 4 . .
        X O . . . X . O O    X O 1 . . X . . O
        . . . X . . . . .    . 1 . X . . . . .
        X . . . . X . . .    X . . . . X . . .
        . . . . . . . . .    . . . . . . . . .

   Since the dragon is trying to reach safety, the reader might wonder
why `compute_influence()' is called with the opposite color of the
dragon contemplating escape.  To explain this point, we first remind
the reader why there is a color parameter to `compute_influence()'.
Consider the following example position:

          ...XX...
          OOO..OOO
          O......O
          O......O
          --------

   Whether the bottom will become O territory depends on who is in turn
to play. This is implemented with the help of patterns in barriers.db,
so that X influence is allowed to leak into the bottom if X is in turn
to move but not if O is. There are also "invade" patterns which add
influence sources in sufficiently open parts of the board which are
handled differently depending on who is in turn to move.

   In order to decide the territorial value of an O move in the third
line gap above, influence is first computed in the original position
with the opponent (i.e. X) in turn to move. Then the O stone is played
to give:


          ...XX...
          OOO.OOOO
          O......O
          O......O
          --------

   Now influence is computed once more, also this time with X in turn to
move. The difference in territory (as computed from the influence
values) gives the territorial value of the move.

   Exactly how influence is computed for use in the escape route
estimation is all ad hoc. But it makes sense to assume the opponent
color in turn to move so that the escape possibilities aren't
overestimated. After we have made a move in the escape direction it is
after all the opponent's turn.

   The current escape route mechanism seems good enough to be useful
but is not completely reliable. Mostly it seems to err on the side of
being too optimistic.


File: gnugo.info,  Node: Break Ins,  Next: Surrounded Dragons,  Prev: Escape,  Up: Influence

13.10 Break Ins
===============

The code in `breakin.c' break-ins into territories that require deeper
tactical reading and are thus impossible to detect for the influence
module. It gets run after the influence module and revises its
territory valuations.

   The break-in code makes use of two public functions in
`readconnect.c',

   * int break_in(int str, const char goal[BOARDMAX], int *move) 

          Returns WIN if `str' can connect to the area `goal[]' (which
          may or may not contain stones), if the string's owner gets
          the first move.

   * int block_off(int str, const char goal[BOARDMAX], int *move) 

          Returns WIN if `str' cannot connect to the area `goal[]'
          (which may or may not contain stones), if the other color
          moves first.

   These functions are public front ends to their counterparts
`recursive_break_in' and `recursive_block_off', which call each other
recursively.

   The procedure is as follows: We look at all big (>= 10) territory
regions as detected by the influence code. Using the computation of
connection distances from readconnect.c, we compute all nearby vertices
of this territory. We look for the closest safe stones belonging to the
opponent.

   For each such string `str' we call

   * `break_in(str, territory)' if the opponent is assumed to be next
     to move,

   * `block_off(str, territory)' if the territory owner is next.

   If the break in is successful resp. the blocking unsuccessful, we
shrink the territory, and see whether the opponent can still break in.
We repeat this until the territory is shrunk so much that the opponent
can no longer reach it.

   To see the break in code in action run GNU Go on the file
`regression/games/break_in.sgf' with the option `-d0x102000'. Among the
traces you will find:

       Trying to break in from D7 to:
     E9 (1)  F9 (1)  G9 (1)  E8 (1)  F8 (1)  G8 (1)
     H8 (1)  G7 (1)  H7 (1)  J7 (1)  H6 (1)  J6 (1)
     H5 (1)  J5 (1)  H4 (1)  J4 (1)  H3 (1)  J3 (1)
     H2 (1)  J2 (1)
     block_off D7, result 0 PASS (355, 41952 nodes, 0.73 seconds)
     E9 (1)  F9 (1)  G9 (1)  E8 (1)  F8 (1)  G8 (1)
     H8 (1)  G7 (1)  H7 (1)  J7 (1)  H6 (1)  J6 (1)
     H5 (1)  J5 (1)  H4 (1)  J4 (1)  H3 (1)  J3 (1)
     H2 (1)  J2 (1)
     B:F4
       Erasing territory at E8 -b.
       Erasing territory at G3 -b.
       Now trying to break to smaller goal:
     F9 (1)  G9 (1)  F8 (1)  G8 (1)  H8 (1)  G7 (1)
     H7 (1)  J7 (1)  H6 (1)  J6 (1)  H5 (1)  J5 (1)
     H4 (1)  J4 (1)  H3 (1)  J3 (1)  H2 (1)  J2 (1)

   This means that the function `break_in' is called with the goal
marked 'a' in the following diagram. The code attempts to find out
whether it is possible to connect into this area from the string at
`D7'.

        A B C D E F G H J
      9 . . . . a a a . . 9
      8 . . . . a a a a . 8
      7 . . . X O O a a a 7
      6 . . . X X X O a a 6
      5 . . . . + . . a a 5
      4 . . . X . . O a a 4
      3 . . . . X . . a a 3
      2 . . . . . . O a a 2
      1 . . . . . . . . . 1
        A B C D E F G H J

   A breakin is found, so the goal is shrunk by removing `E9' and `J2',
then break_in is called again.

   In order to see what reading is actually done in order to do this
break in, you may load GNU Go in gtp mode, then issue the commands:

     loadsgf break_in.sgf
     = black

     start_sgftrace
     =

     break_in D7 E9 F9 G9 E8 F8 G8 H8 G7 H7 J7 H6 J6 H5 J5 H4 J4 H3 J3 H2 J2
     = 1 E8

     finish_sgftrace vars.sgf
     =

     start_sgftrace
     =

     break_in D7 F9 G9 F8 G8 H8 G7 H7 J7 H6 J6 H5 J5 H4 J4 H3 J3 H2 J2
     = 1 G7

     finish_sgftrace vars1.sgf

   This will produce two sgf files containing the variations caused by
these calls to the breakin code. The second file, `vars1.sgf' will
contain quite a few variations.

   The break in code makes a list of break ins which are found.  When
it is finished, the function `add_expand_territory_move' is called for
each break in, adding a move reason.

   The break in code is slow, and only changes a few moves by the engine
per game. Nevertheless we believe that it contributes substantially to
the strength of the program. The break in code is enabled by default in
GNU Go 3.6 at level 10, and disabled at level 9. In fact, this is the
*only* difference between levels 9 and 10 in GNU Go 3.6.


File: gnugo.info,  Node: Surrounded Dragons,  Next: Influential Patterns,  Prev: Break Ins,  Up: Influence

13.11 Surrounded Dragons
========================

When is a dragon surrounded?

   As has been pointed out by Bruce Wilcox, the geometric lines
connecting groups of the opposite color are often important. It is very
hard to prevent the escape of this `O' dragon:

     ..........
     .....O....
     .X.......X
     .X...O...X
     ..........
     ..........
     ----------

   On the other hand, this dragon is in grave danger:

     ..........
     ..........
     .X.......X
     .....O....
     .X.......X
     .X...O...X
     ..........
     ..........
     ----------

   The difference between these two positions is that in the first, the
`O' dragon crosses the line connecting the top two `X' stones.

   Code in `surround.c' implements a test for when a dragon is
surrounded.  The idea is to compute the convex hull of the _surround
set_, that is, the set stones belonging to unfriendly neighbor dragons.
If the dragon is contained within that hull. If it is, it is said to be
_surrounded_.

   In practice this scheme is modified slightly. The implementation
uses various algorithms to compute distances and hostile stones are
discarded from the surround set when a pair other hostile ones can be
found which makes the considered one useless. For example, in the
following position the bottom `O' stone would get discarded.

     O.X.O
     .....
     .O.O.
     .....
     ..O..

   Also, points are added to the surround set below stones on the
second and third lines. This should account for the edge being a
natural barrier.

   In order to compute distances between corners of the convex hull a
sorting by angle algorithm has been implemented. If the distance
between a pair enclosing stones is large, the surround status gets
decreased to `WEAKLY_SURROUNDED', or even 0 for very large ones.

   The sorting by angle must be explained. A small diagram will
probably help :

     .O.O.
     O...O
     ..X..
     O...O
     .O.O.

   The sorting algorithm will generate this:

     .4.5.
     3...6
     ..X..
     2...7
     .1.8.

   That is, the points are sorted by ascending order of the measure of
the angle S-G-O, where S is SOUTH, G the (approximated) gravity center
of the goal, and O the position of the considered hostile stones.

   The necessity of such sorting appears when one tries to measure
distances between enclosing stones without sorting them, just by using
directly the existing left and right corners arrays. In some positions,
the results will be inconsistent. Imagine, for example a position where
for instance the points 1,2,3,4,6 and 7 were in the left arrary,
leaving only 5 and 8 in the right array. Because of the large distance
between 5 and 8, the dragon would have declared weak surrounded or not
surrounded at all. Such cases are rare but frequent enough to require
the angle sorting.

   The following position:

     O.X.O
     .....
     .O.O.

   This is "more" surrounded than the following position:

     O.XXXXXX.O
     ..........
     .O......O.

   In the second case, the surround status would be lowered to
`WEAKLY_SURROUNDED'.

   The surround code is used to modify the escape_route field in the
dragon2 data array. When a dragon is WEAKLY_SURROUNDED, the
escape_route is divided by 2. If the dragon is SURROUNDED, escape_route
is simply set to 0.


File: gnugo.info,  Node: Influential Patterns,  Next: Influential Display,  Prev: Surrounded Dragons,  Up: Influence

13.12 Patterns used by the Influence module
===========================================

This section explains the details of the pattern databases used for the
influence computation.

   First, we have the patterns in `influence.db', which get matched
symmetrically for both colors.

   * `E'

          These patterns add extra influence sources close to some
          shapes like walls.  This tries to reflect their extra
          strength. These patterns are not used in the influence
          computations relevant for territory valuations, but they are
          useful for getting a better estimate of strengths of groups.

   * `I'

          These patterns add extra influence sources at typical
          invasion points.  Usually they are of small strength. If they
          additionally have the class `s', the extra influence source
          is added for both colors. Otherwise, only the player assumed
          to be next to move gets the benefit.

   The patterns in `barriers.db' get matched only for `O' being the
player next to move.

   * `A'

          Connections between `X' stones that stop influence of `O'.
          They have to be tight enough that `O' cannot break through,
          even though he is allowed to move first.

   * `D'

          Connections between `O' stones that stop influence of `X'. The
          stones involved can be more loosely connected than those in
          `A' patterns.

   * `B'

          These indicate positions of followup moves for the `O' stone
          marked with `Q' in the pattern. They are used to reduce the
          territory e. g.  where a monkey jump is possible. Also, they
          are used in the computation of the followup influence, if the
          `Q' stone was the move played (or a stone saved by the move
          played).

   * `t'

          These patterns indicate intersections where one color will
          not be able to get territory, for example in a false eye. The
          points are set with a call to the helper non_oterritory or
          non_xterritory in the action of the pattern.

   The intrusion patterns (`B') are more powerful than the description
above might suggest. They can be very helpful in identifying weak shapes
(by adding an intrusion source for the opponent where he can break
through).  A negative inference for this is that a single bad `B'
pattern, e. g.  one that has a wrong constraint, typically causes 5 to
10 `FAIL's in the regression test suite.

   Influence Patterns can have autohelper constraints as usual. As for
the constraint attributes, there are (additionally to the usual ones
`O', `o', `X' and `x'), attributes `Y' and `FY'. A pattern marked with
`Y' will only be used in the influence computations relevant for the
territory valuation, while `FY' patterns only get used in the other
influence computations.

   The action of an influence pattern is at the moment only used for
non-territory patterns as mentioned above, and as a workaround for a
problem with `B' patterns in the followup influence.

   To see why this workaround is necessary, consider the follwoing
situation:


     ..XXX
     .a*.O
     .X.O.
     ..XXO

   (Imagine that there is `X' territory on the left.)

   The move by `O' at `*' has a natural followup move at `a'.  So, in
the computation of the followup influence for `*', there would be an
extra influence source for `O' at `a' which would destroy a lot of
black territory on the left. This would give a big followup value, and
in effect the move `*' would be treated as sente.

   But of course it is gote, since `X' will answer at `a', which both
stops the possible intrusion and  threatens to capture `*'. This
situation is in fact quite common.

   Hence we need an additional constraint that can tell when an
intrusion pattern can be used in followup influence. This is done by
misusing the action line: An additional line

     >return <condition>;

   gets added to the pattern. The `condition' should be true if the
intrusion cannot be stopped in sente. In the above example, the relevant
intrusion pattern will have an action line of the form

     >return (!xplay_attack(a,b));

   where `b' refers to the stone at `*'. In fact, almost all
followup-specific constraints look similar to this.


File: gnugo.info,  Node: Influential Display,  Next: Influence Tuning,  Prev: Influential Patterns,  Up: Influence

13.13 Colored display and debugging of influence
================================================

There are various ways to obtain detailed information about the
influence computations. Colored diagrams showing influence are possible
from a colored xterm or rxvt window.

   There are two options controlling when to generate diagrams:

   * `-m 0x08' or `-m 8'

          Show diagrams for the initial influence computation. This is
          done twice, the first time before `make_dragons()' is run and
          the second time after. The difference is that dead dragons
          are taken into account the second time. Tactically captured
          worms are taken into account both times.

   * `--debug-influence LOCATION'

          Show influence diagrams after the move at the given location.
          An important limitation of this option is that it's only
          effective for moves that the move generation is considering.

   The other options control which diagrams should be generated in these
situations. You have to specify at least one of the options above and
at least one of the options below to generate any output.

   * The options below must be combined with one of the two previous
ones, or the diagram will not be printed. For example to print the
influence diagram, you may combine 0x08 and 0x010, and use the option
`-m 0x018'.*

   * `-m 0x010' or `-m 16'

          Show colored display of territory/moyo/area regions.
             - territory: cyan

             - moyo: yellow

             - area: red
          This feature is very useful to get an immediate impression of
          the influence regions as GNU Go sees them.

   * `-m 0x20' or `-m 32'

          Show numerical influence values for white and black. These
          come in two separate diagrams, the first one for white, the
          second one for black. Notice that the influence values are
          represented by floats and thus have been rounded in these
          diagrams.

   * `-m 0x40' or `-m 64'

          This generates two diagrams showing the permeability for
          black and white influence on the board.

   * `-m 0x80' or `-m 128'

          This shows the strength of the influence sources for black
          and white across the board. You will see sources at each
          lively stone (with strength depending on the strength of this
          stone), and sources contributed by patterns.

   * `-m 0x100' or `-m 256'

          This shows the attenuation with which the influence sources
          spread influence across the board. Low attenuation indicates
          far-reaching influence sources.

   * `-m 0x200' or `-m 512'

          This shows the territory valuation of GNU Go. Each
          intersection is shown with a value between -1.0 and +1.0 (or
          -2 resp. +2 if there is a dead stone on this intersection).
          Positive values indicate territory for white. A value of -0.5
          thus indicates a point where black has a 50% chance of
          getting territory.

   Finally, there is the debug option `-d 0x1' which turns on on
`DEBUG_INFLUENCE'. This gives a message for each influence pattern that
gets matched. Unfortunately, these are way too many messages making it
tedious to navigate the output. However, if you discover an influence
source with `-m 0x80' that looks wrong, the debug output can help you
to quickly find out the responsible pattern.


File: gnugo.info,  Node: Influence Tuning,  Prev: Influential Display,  Up: Influence

13.14 Influence Tuning with `view.pike'
=======================================

A useful program in the regression directory is `view.pike'.  To run
it, you need Pike, which you may download from
`http://pike.ida.liu.se/'.

   The test case `endgame:920' fails in GNU Go 3.6. We will explain how
to fix it.

   Start by firing up view.pike on testcase endgame:920, e.g. by running
`pike view.pike endgame:920' in the regression directory.

   We see from the first view of move values that filling dame at P15 is
valued highest with 0.17 points while the correct move at C4 is valued
slightly lower with 0.16. The real problem is of course that C4 is
worth a full point and thus should be valued about 1.0.

   Now click on C4 to get a list of move reasons and move valuation
information. Everything looks okay except that change in territory is
0.00 rather than 1.00 as it ought to be.

   We can confirm this by choosing the "delta territory for..." button
and again clicking C4. Now B5 should have been marked as one point of
change in territory, but it's not.

   Next step is to enter the influence debug tool. Press the "influence"
button, followed by "black influence, dragons known," and "territory
value." This shows the expected territory if black locally moves first
everywhere (thus "black influence"). Here we can see that B5 is
incorrectly considered as 1.0 points of white territory.

   We can compare this with the territory after a white move at C4
(still assuming that black locally moves first everywhere after that) by
pressing "after move influence for..." and clicking C4. This looks
identical, as expected since delta territory was 0, but here it is
correct that B5 is 1.0 points of territory for white.

   The most straightforward solution to this problem is to add a
non-territory pattern, saying that white can't get territory on B5 if
black moves first. The nonterritory patterns are in `barriers.db'.

     Pattern Nonterritory56

     ...
     X.O
     ?O.

     :8,t

     eac
     XbO
     ?Od

     ;oplay_attack(a,b,c,d,d)

     >non_xterritory(e);

   In these patterns it's always assumed that `O' moves first and thus
it says that `X' can't get territory at `B5' (`e' in the pattern). Now
we need to be a bit careful however since after `O' plays at `a' and
`X' cuts in at `b', it may well happen that `O' needs to defend around
`d', allowing `X' to cut at `c', possibly making the nonterritory
assumption invalid. It's difficult to do this entirely accurate, but
the constraint above is fairly conservative and should guarantee that
`a' is safe in most, although not all, cases.


File: gnugo.info,  Node: Alternative Moyo,  Next: Libboard,  Prev: Influence,  Up: Top

14 Another approach to Moyos : Bouzy's 5/21 algorithm
*****************************************************

* Menu:

* Moyo history::		History of `moyo.c' and `score.c'
* Bouzy::                       Bouzy's algorithm

   The file `score.c' contains alternative algorithms for the
computation of Territory and Moyos. These algorithms are used in
`estimate_score()' but apart from that are generally *not* used in the
rest of the engine since the concepts of Territory, Moyo and Area were
reimplemented using the influence code (*note Territory and Moyo::).
The function `estimate_score()', which is the only way this code is
used in the engine, could easily be replaced with a function such as
`influence_score()' based on the influence code.


File: gnugo.info,  Node: Moyo history,  Next: Bouzy,  Up: Alternative Moyo

14.1 Moyo history
=================

In GNU Go 2.6 extensive use was made of an algorithm from Bruno Bouzy's
dissertation, which is available at:
`ftp://www.joy.ne.jp/welcome/igs/Go/computer/bbthese.ps.Z' This
algorithm starts with the characteristic function of the live groups on
the board and performs `n' operations called dilations, then `m'
operations called erosions.  If n=5 and m=21 this is called the 5/21
algorithm.

   The Bouzy 5/21 algorithm is interesting in that it corresponds
reasonably well to the human concept of territory.  This algorithm is
still used in GNU Go 3.6 in the function `estimate_score'. Thus we
associate the 5/21 algorithm with the word "territory". Similarly we
use words "moyo" and "area" in reference to the 5/10 and 4/0
algorithms, respectively.

   The principle defect of the algorithm is that it is not tunable. The
current method of estimating moyos and territory is in `influence.c'
(*note Influence::). The territory, moyo and area concepts have been
reimplemented using the influence code.

   The Bouzy algorithm is briefly reimplemented in the file `scoring.c'
and is used by GNU Go 3.6 in estimating the score.

   Not all features of the old `moyo.c' from GNU Go 2.6 were
reimplemented--particularly the deltas were not--but the
reimplementation may be more readable.


File: gnugo.info,  Node: Bouzy,  Prev: Moyo history,  Up: Alternative Moyo

14.2 Bouzy's 5/21 algorithm
===========================

Bouzy's algorithm was inspired by prior work of Zobrist and ideas from
computer vision for determining territory. This algorithm is based on
two simple operations, DILATION and EROSION. Applying dilation 5 times
and erosion 21 times determines the territory.

   To get a feeling for the algorithm, take a position in the early
middle game and try the colored display using the `-m 1' option in an
RXVT window. The regions considered territory by this algorithm tend to
coincide with the judgement of a strong human player.

   Before running the algorithm, dead stones (`dragon.status==0') must
be "removed."

   Referring to page 86 of Bouzy's thesis, we start with a function
taking a high value (ex : +128 for black, -128 for white) on stones on
the goban, 0 to empty intersections. We may iterate the following
operations:

   "dilation": for each intersection of the goban, if the intersection
is `>= 0', and not adjacent to a `< 0' one, then add to the intersection
the number of adjacent >0 intersections. The same for other color : if
the intersection is `<= 0', and not adjacent to a `> 0' one, then
subtract the number of `< 0' intersections.

   "erosion": for each intersection `> 0' (or `< 0'), subtract (or add)
the number of adjacent `<= 0' (or `>= 0') intersection. Stop at zero.
The algorithm is just : 5 dilations, then 21 erosions. The number of
erosions should be 1+n(n-1) where n=number of dilation, since this
permit to have an isolated stone to give no territory. Thus the couple
4/13 also works, but it is often not good, for example when there is
territory on the 6th line.

   For example, let us start with a tobi.


                128    0    128

   1 dilation :


                 1          1

            1   128    2   128   1

                 1          1

   2 dilations :


                 1          1

            2    2     3    2    2

        1   2   132    4   132   2   1

            2    2     3    2    2

                 1          1

   3 dilations :


                 1          1

            2    2     3    2    2

        2   4    6     6    6    4   2

     1  2   6   136    8   136   6   2   1

        2   4    6     6    6    4   2

            2    2     3    2    2

                 1          1

   and so on...

   Next, with the same example

   3 dilations and 1 erosion :


                  2     2     2

         0   4    6     6     6    4

     0   2   6   136    8    136   6    2

         0   4    6     6     6    4

                  2     2     2

   3 dilations and 2 erosions :


                      1

           2    6     6     6    2

           6   136    8    136   6

           2    6     6     6    2

                      1

   3 dil. / 3 erosions :


                5     6     5

           5   136    8    136   5

                5     6     5

   3/4 :


               3     5     3

           2  136    8    136   2

               3     5     3

   3/5 :


               1     4     1

              136    8    136

               1     4     1

   3/6 :


                     3

              135    8    135

                     3

   3/7 :


              132    8    132

   We interpret this as a 1 point territory.


File: gnugo.info,  Node: Libboard,  Next: SGF,  Prev: Alternative Moyo,  Up: Top

15 The Board Library
********************

* Menu:

* Board Data Structures::      Board Data Structures
* The Board Array::	       One-dimensional board array
* Incremental Board::	  	Incremental board data structures
* Some Board Functions::      	Explanation of some board functions

   The foundation of the GNU Go engine is a library of very efficient
routines for handling go boards.  This board library, called
`libboard', can be used for those programs that only need a basic go
board but no AI capability. One such program is `patterns/joseki.c',
which compiles joseki pattern databases from SGF files.

   If you want to use the board library in your own program, you need
all the .c-files listed under libboard_SOURCES in engine/Makefile.am,
and the files in the directories sgf/ and utils/. Then you should
include engine/board.h in your code.

   The library consists of the following files:

   * `board.h'

          The public interface to the board library.

   * `board.c'

          The basic board code. It uses incremental algorithms for
          keeping track of strings and liberties on the go board.

   * `boardlib.c'

          This contains all global variable of the board library.

   * `hash.c'

          Code for hashing go positions.

   * `sgffile.c'

          Implementation of output file in SGF format.

   * `printutils.c'

          Utilities for printing go boards and other things.


   To use the board library, you must include `liberty.h' just like
when you use the whole engine, but of course you cannot use all the
functions declared in it, i.e. the functions that are part of the
engine, but not part of the board library.  You must link your
application with `libboard.a'.


File: gnugo.info,  Node: Board Data Structures,  Next: The Board Array,  Up: Libboard

15.1 Board Data structures
==========================

The basic data structures of the board correspond tightly to the
`board_state' struct described in *Note The Board State::. They are all
stored in global variables for efficiency reasons, the most important
of which are:


     int           board_size;
     Intersection  board[MAXSIZE];
     int           board_ko_pos;

     float         komi;
     int           white_captured;
     int           black_captured;

     Hash_data     hashdata;

   The description of the `Position' struct is applicable to these
variables also, so we won't duplicate it here.  All these variables are
globals for performance reasons.  Behind these variables, there are a
number of other private data structures.  These implement incremental
handling of strings, liberties and other properties (*note Incremental
Board::). The variable `hashdata' contains information about the hash
value for the current position (*note Hashing::).

   These variables should never be manipulated directly, since they are
only the front end for the incremental machinery. They can be read, but
should only be written by using the functions described in the next
section. If you write directly to them, the incremental data structures
will become out of sync with each other, and a crash is the likely
result.


File: gnugo.info,  Node: The Board Array,  Next: Incremental Board,  Prev: Board Data Structures,  Up: Libboard

15.2 The Board Array
====================

GNU Go represents the board in a one-dimensional array called `board'.
For some purposes a two dimensional indexing of the board by parameters
`(i,j)' might be used.

   The `board' array includes out-of-board markers around the board. To
make the relation to the old two-dimensional board representation
clear, this figure shows how the 1D indices correspond to the 2D
indices when MAX_BOARD is 7.

       j  -1   0   1   2   3   4   5   6
     i +----------------------------------
     -1|   0   1   2   3   4   5   6   7
      0|   8   9  10  11  12  13  14  15
      1|  16  17  18  19  20  21  22  23
      2|  24  25  26  27  28  29  30  31
      3|  32  33  34  35  36  37  38  39
      4|  40  41  42  43  44  45  46  47
      5|  48  49  50  51  52  53  54  55
      6|  56  57  58  59  60  61  62  63
      7|  64  65  66  67  68  69  70  71  72

   To convert between a 1D index `pos' and a 2D index `(i,j)', the
macros `POS', `I', and `J' are provided, defined as below:

     #define POS(i, j)    ((MAX_BOARD + 2) + (i) * (MAX_BOARD + 1) + (j))
     #define I(pos)       ((pos) / (MAX_BOARD + 1) - 1)
     #define J(pos)       ((pos) % (MAX_BOARD + 1) - 1)

   All 1D indices not corresponding to points on the board have the out
of board marker value `GRAY'. Thus if `board_size' and `MAX_BOARD' both
are 7, this looks like

       j  -1   0   1   2   3   4   5   6
     i +----------------------------------
     -1|   #   #   #   #   #   #   #   #
      0|   #   .   .   .   .   .   .   .
      1|   #   .   .   .   .   .   .   .
      2|   #   .   .   .   .   .   .   .
      3|   #   .   .   .   .   .   .   .
      4|   #   .   .   .   .   .   .   .
      5|   #   .   .   .   .   .   .   .
      6|   #   .   .   .   .   .   .   .
      7|   #   #   #   #   #   #   #   #   #

   The indices marked `#' have value `GRAY'.  If `MAX_BOARD' is 7 and
`board_size' is only 5:

       j  -1   0   1   2   3   4   5   6
     i +----------------------------------
     -1|   #   #   #   #   #   #   #   #
      0|   #   .   .   .   .   .   #   #
      1|   #   .   .   .   .   .   #   #
      2|   #   .   .   .   .   .   #   #
      3|   #   .   .   .   .   .   #   #
      4|   #   .   .   .   .   .   #   #
      5|   #   #   #   #   #   #   #   #
      6|   #   #   #   #   #   #   #   #
      7|   #   #   #   #   #   #   #   #   #

   Navigation on the board is done by the `SOUTH', `WEST', `NORTH', and
`EAST' macros,

     #define NS           (MAX_BOARD + 1)
     #define WE           1
     #define SOUTH(pos)   ((pos) + NS)
     #define WEST(pos)    ((pos) - 1)
     #define NORTH(pos)   ((pos) - NS)
     #define EAST(pos)    ((pos) + 1)

   There are also shorthand macros `SW', `NW', `NE', `SE', `SS', `WW',
`NN', `EE' for two step movements.

   Any movement from a point on the board to an adjacent or diagonal
vertex is guaranteed to produce a valid index into the board array, and
the color found is GRAY if it is not on the board. To do explicit tests
for out of board there are two macros

     #define ON_BOARD(pos) (board[pos] != GRAY)
     #define ON_BOARD1(pos) (((unsigned) (pos) < BOARDSIZE) && board[pos] != GRAY)

   where the first one should be used in the algorithms and the second
one is useful for assertion tests.

   The advantage of a one-dimensional board array is that it gives a
significant performance advantage. We need only one variable to
determine a board position, which means that many functions need less
arguments. Also, often one computation is sufficient for 1D-coordinate
where we would need two with two 2D-coordinates: If we, for example,
want to have the coordinate of the upper right of `pos', we can do this
with `NORTH(EAST(pos))' instead of `(i+1, j-1)'.

   *Important*: The 2D coordinate `(-1,-1)', which is used for pass and
sometimes to indicate no point, maps to the 1D coordinate `0', not to
`-1'. Instead of a plain `0', use one of the macros `NO_MOVE' or
`PASS_MOVE'.

   A loop over multiple directions is straightforwardly written:

       for (k = 0; k < 4; k++) {
         int d = delta[k];
         do_something(pos + d);
       }

   The following constants are useful for loops over the entire board
and allocation of arrays with a 1-1 mapping to the board.

     #define BOARDSIZE    ((MAX_BOARD + 2) * (MAX_BOARD + 1) + 1)
     #define BOARDMIN     (MAX_BOARD + 2)
     #define BOARDMAX     (MAX_BOARD + 1) * (MAX_BOARD + 1)

   `BOARDSIZE' is the actual size of the 1D board array, `BOARDMIN' is
the first index corresponding to a point on the board, and `BOARDMAX'
is one larger than the last index corresponding to a point on the board.

   Often one wants to traverse the board, carrying out some function at
every vertex. Here are two possible ways of doing this:

       int m, n;
       for (m = 0; m < board_size; m++)
         for (n = 0; n < board_size; n++) {
           do_something(POS(m, n));
         }

   Or:

       int pos;
       for (pos = BOARDMIN; pos < BOARDMAX; pos++) {
         if (ON_BOARD(pos))
           do_something(pos);
       }


File: gnugo.info,  Node: Incremental Board,  Next: Some Board Functions,  Prev: The Board Array,  Up: Libboard

15.3 Incremental Board data structures
======================================

In addition to the global board state, the algorithms in `board.c'
implement a method of incremental updates that keeps track of the
following information for each string:

   * The color of the string.

   * Number of stones in the string.

   * Origin of the string, i.e. a canonical reference point, defined to
     be the stone with smallest 1D board coordinate.

   * A list of the stones in the string.

   * Number of liberties.

   * A list of the liberties. If there are too many liberties the list
     is truncated.

   * The number of neighbor strings.

   * A list of the neighbor strings.

   The basic data structure is

     struct string_data {
       int color;                       /* Color of string, BLACK or WHITE */
       int size;                        /* Number of stones in string. */
       int origin;                      /* Coordinates of "origin", i.e. */
                                        /* "upper left" stone. */
       int liberties;                   /* Number of liberties. */
       int libs[MAX_LIBERTIES];         /* Coordinates of liberties. */
       int neighbors;                   /* Number of neighbor strings */
       int neighborlist[MAXCHAIN];      /* List of neighbor string numbers. */
       int mark;                        /* General purpose mark. */
     };

     struct string_data string[MAX_STRINGS];

   It should be clear that almost all information is stored in the
`string' array. To get a mapping from the board coordinates to the
`string' array we have

     static int string_number[BOARDMAX];

which contains indices into the `string' array. This information is only
valid at nonempty vertices, however, so it is necessary to first verify
that `board[pos] != EMPTY'.

   The `string_data' structure does not include an array of the stone
coordinates. This information is stored in a separate array:

     static int next_stone[BOARDMAX];

   This array implements cyclic linked lists of stones. Each vertex
contains a pointer to another (possibly the same) vertex. Starting at
an arbitrary stone on the board, following these pointers should
traverse the entire string in an arbitrary order before coming back to
the starting point. As for the 'string_number' array, this information
is invalid at empty points on the board. This data structure has the
good properties of requiring fixed space (regardless of the number of
strings) and making it easy to add a new stone or join two strings.

   Additionally the code makes use of some work variables:

     static int ml[BOARDMAX];
     static int liberty_mark;
     static int string_mark;
     static int next_string;
     static int strings_initialized = 0;

   The `ml' array and `liberty_mark' are used to "mark" liberties on
the board, e.g. to avoid counting the same liberty twice. The
convention is that if `ml[pos]' has the same value as `liberty_mark',
then `pos' is marked. To clear all marks it suffices to increase the
value of `liberty_mark', since it is never allowed to decrease.

   The same relation holds between the `mark' field of the `string_data'
structure and `string_mark'. Of course these are used for marking
individual strings.

   `next_string' gives the number of the next available entry in the
`string' array. Then `strings_initialized' is set to one when all data
structures are known to be up to date. Given an arbitrary board
position in the `board' array, this is done by calling
`incremental_board_init()'. It is not necessary to call this function
explicitly since any other function that needs the information does
this if it has not been done.

   The interesting part of the code is the incremental update of the
data structures when a stone is played and subsequently removed. To
understand the strategies involved in adding a stone it is necessary to
first know how undoing a move works. The idea is that as soon as some
piece of information is about to be changed, the old value is pushed
onto a stack which stores the value and its address. The stack is built
from the following structures:

     struct change_stack_entry {
       int *address;
       int value;
     };

     struct change_stack_entry change_stack[STACK_SIZE];
     int change_stack_index;

and manipulated with the macros

     BEGIN_CHANGE_RECORD()
     PUSH_VALUE(v)
     POP_MOVE()

   Calling `BEGIN_CHANGE_RECORD()' stores a null pointer in the address
field to indicate the start of changes for a new move. As mentioned
earlier `PUSH_VALUE()' stores a value and its corresponding address.
Assuming that all changed information has been duly pushed onto the
stack, undoing the move is only a matter of calling `POP_MOVE()', which
simply assigns the values to the addresses in the reverse order until
the null pointer is reached. This description is slightly simplified
because this stack can only store 'int' values and we need to also
store changes to the board. Thus we have two parallel stacks where one
stores `int' values and the other one stores `Intersection' values.

   When a new stone is played on the board, first captured opponent
strings, if any, are removed. In this step we have to push the board
values and the `next_stone' pointers for the removed stones, and update
the liberties and neighbor lists for the neighbors of the removed
strings. We do not have to push all information in the 'string' entries
of the removed strings however. As we do not reuse the entries they
will remain intact until the move is pushed and they are back in use.

   After this we put down the new stone and get three distinct cases:

  1. The new stone is isolated, i.e. it has no friendly neighbor.

  2. The new stone has exactly one friendly neighbor.

  3. The new stone has at least two friendly neighbors.

   The first case is easiest. Then we create a new string by using the
number given by `next_string' and increasing this variable. The string
will have size one, `next_stone' points directly back on itself, the
liberties can be found by looking for empty points in the four
directions, possible neighbor strings are found in the same way, and
those need also to remove one liberty and add one neighbor.

   In the second case we do not create a new string but extend the
neighbor with the new stone. This involves linking the new stone into
the cyclic chain, if needed moving the origin, and updating liberties
and neighbors. Liberty and neighbor information also needs updating for
the neighbors of the new stone.

   In the third case finally, we need to join already existing strings.
In order not to have to store excessive amounts of information, we
create a new string for the new stone and let it assimilate the
neighbor strings. Thus all information about those can simply be left
around in the 'string' array, exactly as for removed strings. Here it
becomes a little more complex to keep track of liberties and neighbors
since those may have been shared by more than one of the joined
strings. Making good use of marks it all becomes rather straightforward
anyway.

   The often used construction

         pos = FIRST_STONE(s);
         do {
             ...
             pos = NEXT_STONE(pos);
         } while (!BACK_TO_FIRST_STONE(s, pos));

traverses the stones of the string with number `s' exactly once, with
`pos' holding the coordinates. In general `pos' is used as board
coordinate and `s' as an index into the `string' array or sometimes a
pointer to an entry in the `string' array.


File: gnugo.info,  Node: Some Board Functions,  Prev: Incremental Board,  Up: Libboard

15.4 Some Board Functions
=========================

*Reading*, often called *search* in computer game theory, is a
fundamental process in GNU Go. This is the process of generating
hypothetical future boards in order to determine the answer to some
question, for example "can these stones live."  Since these are
hypothetical future positions, it is important to be able to undo them,
ultimately returning to the present board. Thus a move stack is
maintained during reading. When a move is tried, by the function
`trymove', or its variant `tryko'. This function pushes the current
board on the stack and plays a move. The stack pointer `stackp', which
keeps track of the position, is incremented. The function `popgo()'
pops the move stack, decrementing `stackp' and undoing the last move
made.

   Every successful `trymove()' must be matched with a `popgo()'.  Thus
the correct way of using this function is:


       if (trymove(pos, color, ... )) {
            ...    [potentially lots of code here]
            popgo();
       }

In case the move is a ko capture, the legality of the capture is
subject to the komaster scheme (*note Ko::).

   * `int trymove(int pos, int color, const char *message)' 

          Returns true if `(pos)' is a legal move for `color'. In that
          case, it pushes the board on the stack and makes the move,
          incrementing `stackp'. If the reading code is recording
          reading variations (as with `--decide-string' or with `-o'),
          the string `*message' will be inserted in the SGF file as a
          comment. The comment will also refer to the string at `str'
          if this is not `0'. The value of `str' can be NO_MOVE if it
          is not needed but otherwise the location of `str' is included
          in the comment.

   * `int tryko(int pos, int color, const char *message)' 

          `tryko()' pushes the position onto the stack, and makes a move
          `pos' of `color'. The move is allowed even if it is an
          illegal ko capture. It is to be imagined that `color' has
          made an intervening ko threat which was answered and now the
          continuation is to be explored. Return 1 if the move is legal
          with the above caveat. Returns zero if it is not legal
          because of suicide.

   * `void popgo()' 

          Pops the move stack. This function must (eventually) be
          called after a succesful `trymove' or `tryko' to restore the
          board position. It undoes all the changes done by the call to
          `trymove/tryko' and leaves the board in the same state as it
          was before the call.

          *NOTE*: If `trymove/tryko' returns `0', i.e. the tried move
          was not legal, you must *not* call `popgo'.

   * `int komaster_trymove(int pos, int color, const char *message, int
     str, int *is_conditional_ko, int consider_conditional_ko)' 

          Variation of `trymove'/`tryko' where ko captures (both
          conditional and unconditional) must follow a komaster scheme
          (*note Ko::).


   As you see, `trymove()' plays a move which can be easily retracted
(with `popgo()') and it is call thousands of times per actual game move
as GNU Go analyzes the board position.  By contrast the function
`play_move()' plays a move which is intended to be permanent, though it
is still possible to undo it if, for example, the opponent retracts a
move.

   * `void play_move(int pos, int color)' 

          Play a move. If you want to test for legality you should
          first call `is_legal()'. This function strictly follows the
          algorithm:
            1. Place a stone of given color on the board.

            2. If there are any adjacent opponent strings without
               liberties, remove them and increase the prisoner count.

            3. If the newly placed stone is part of a string without
               liberties, remove it and increase the prisoner count.
               In spite of the name "permanent move", this move can
          (usually) be unplayed by `undo_move()', but it is
          significantly more costly than unplaying a temporary move.
          There are limitations on the available move history, so under
          certain circumstances the move may not be possible to unplay
          at a later time.

   * `int undo_move(int n)' 

          Undo `n' permanent moves. Returns 1 if successful and 0 if it
          fails.  If `n' moves cannot be undone, no move is undone.

   Other board functions are documented in *Note Board Utilities::.


File: gnugo.info,  Node: SGF,  Next: DFA,  Prev: Libboard,  Up: Top

16 Handling SGF trees in memory
*******************************

"SGF" - Smart Game Format - is a file format which is used for storing
game records for a number of different games, among them chess and go.
The format is a framework with special adaptions to each game. This is
not a description of the file format standard. Too see the exact
definition of the file format, see `http://www.red-bean.com/sgf/'.

   GNU Go contains a library to handle go game records in the SGF
format in memory and to read and write SGF files. This library -
`libsgf.a' - is in the `sgf' subdirectory. To use the SGF routines,
include the file `sgftree.h'.

   Each game record is stored as a tree of "nodes", where each node
represents a state of the game, often after some move is made. Each node
contains zero or more "properties", which gives meaning to the node.
There can also be a number of "child nodes" which are different
variations of the game tree. The first child node is the main variation.

   Here is the definition of `SGFNode', and `SGFProperty', the data
structures which are used to encode the game tree.


     typedef struct SGFProperty_t {
       struct SGFProperty_t *next;
       short  name;
       char   value[1];
     } SGFProperty;

     typedef struct SGFNode_t {
       SGFProperty      *props;
       struct SGFNode_t *parent;
       struct SGFNode_t *child;
       struct SGFNode_t *next;
     } SGFNode;

   Each node of the SGF tree is stored in an `SGFNode' struct. It has a
pointer to a linked list of properties (see below) called `props'. It
also has a pointer to a linked list of children, where each child is a
variation which starts at this node. The variations are linked through
the `next' pointer and each variation continues through the `child'
pointer. Each and every node also has a pointer to its parent node (the
`parent' field), except the top node whose parent pointer is `NULL'.

   An SGF property is encoded in the `SGFPoperty' struct. It is linked
in a list through the `next' field.  A property has a `name' which is
encoded in a short int.  Symbolic names of properties can be found in
`sgf_properties.h'.

   Some properties also have a value, which could be an integer, a
floating point value, a character or a string. These values can be
accessed or set through special functions.

16.1 The SGFTree datatype
=========================

Sometimes we just want to record an ongoing game or something similarly
simple and not do any sofisticated tree manipulation.  In that case we
can use the simplified interface provided by `SGFTree' below.


     typedef struct SGFTree_t {
       SGFNode *root;
       SGFNode *lastnode;
     } SGFTree;

   An `SGFTree' contains a pointer to the root node of an SGF tree and
a pointer to the node that we last accessed. Most of the time this will
be the last move of an ongoing game.

   Most of the functions which manipulate an `SGFTree' work exactly
like their `SGFNode' counterparts, except that they work on the current
node of the tree.

   All the functions below that take arguments `tree' and `node' will
work on:

  1. `node' if non-`NULL'

  2. `tree->lastnode' if non-`NULL'

  3. The current end of the game tree.
        in that order.


File: gnugo.info,  Node: API,  Next: GTP,  Prev: Utility Functions,  Up: Top

17 Application Programmers Interface to GNU Go
**********************************************

If you want to write your own interface to GNU Go, or if you want to
create a go application using the GNU Go engine, this chapter is of
interest to you.

   First an overview: GNU Go consists of two parts: the GNU Go engine
and a program (user interface) which uses this engine. These are linked
together into one binary. The current program implements the following
user modes:

   * An interactive board playable on ASCII terminals

   * solo play - GNU Go plays against itself

   * replay - a mode which lets the user investigate moves in an
     existing SGF file.

   * GMP - Go Modem Protocol, a protocol for automatic play between two
     computers.

   * GTP - Go Text Protocol, a more general go protocol, *note GTP::.
   
   The GNU Go engine can be used in other applications. For example,
supplied with GNU Go is another program using the engine, called
`debugboard', in the directory `interface/debugboard/'. The program
debugboard lets the user load SGF files and can then interactively look
at different properties of the position such as group status and eye
status.

   The purpose of this Chapter is to show how to interface your own
program such as `debugboard' with the GNU Go engine.

   Figure 1 describes the structure of a program using the GNU Go
engine.

                      +-----------------------------------+
                      |                                   |
                      |          Go application           |
                      |                                   |
                      +-----+----------+------+           |
                      |     |          |      |           |
                      |     |   Game   |      |           |
                      |     | handling |      |           |
                      |     |          |      |           |
                      |     +----+-----+      |           |
                      |   SGF    |    Move    |           |
                      | handling | generation |           |
                      |          |            |           |
                      +----------+------------+-----------+
                      |                                   |
                      |           Board handling          |
                      |                                   |
                      +-----------------------------------+

             Figure 1: The structure of a program using the GNU Go engine

   The foundation is a library called `libboard.a' which provides
efficient handling of a go board with rule checks for moves, with
incremental handling of connected strings of stones and with methods to
efficiently hash go positions.

   On top of this, there is a library which helps the application use
Smart Game Format (SGF) files, with complete handling of game trees in
memory and in files. This library is called `libsgf.a'

   The main part of the code within GNU Go is the move generation
library which given a position generates a move. This part of the
engine can also be used to manipulate a go position, add or remove
stones, do tactical and strategic reading and to query the engine for
legal moves. These functions are collected into `libengine.a'.

   The game handling code helps the application programmer keep tracks
of the moves in a game. Games can be saved to SGF files and then later
be read back again. These are also within `libengine.a'.

   The responsibility of the application is to provide the user with a
user interface, graphical or not, and let the user interact with the
engine.

* Menu:

* Getting Started::          How to use the engine in your program
* Basic Data Structures::    Basic Data Structures in the Engine
* The Board State::          The board_state `struct'
* Positional Functions::     Functions which manipulate a Position


File: gnugo.info,  Node: Getting Started,  Next: Basic Data Structures,  Up: API

17.1 How to use the engine in your own program: getting started
===============================================================

To use the GNU Go engine in your own program you must include the file
`gnugo.h'. This file describes the whole public API. There is another
file, `liberty.h', which describes the internal interface within the
engine. If you want to make a new module within the engine, e.g.  for
suggesting moves you will have to include this file also. In this
section we will only describe the public interface.

   Before you do anything else, you have to call the function
`init_gnugo()'. This function initializes everything within the engine.
It takes one parameter: the number of megabytes the engine can use for
the internal hash table. In addition to this the engine will use a few
megabytes for other purposes such as data describing groups (liberties,
life status, etc), eyes and so on.


File: gnugo.info,  Node: Basic Data Structures,  Next: The Board State,  Prev: Getting Started,  Up: API

17.2 Basic Data Structures in the Engine
========================================

There are some basic definitions in gnugo.h which are used everywhere.
The most important of these are the numeric declarations of colors.
Each intersection on the board is represented by one of these:


          color              value
          EMPTY                0
          WHITE                1
          BLACK                2

   There is a macro, `OTHER_COLOR(color)' which can be used to get the
other color than the parameter. This macro can only be used on `WHITE'
or `BLACK', but not on `EMPTY'.  

   GNU Go uses two different representations of the board, for most
purposes a one-dimensional one, but for a few purposes a two
dimensional one (*note Libboard::). The one-dimensional board was
introduced before GNU Go 3.2, while the two-dimensional board dates
back to the ancestral program written by Man Lung Li before 1995. The
API still uses the two-dimensional board, so the API functions have not
changed much since GNU Go 3.0.


File: gnugo.info,  Node: The Board State,  Next: Positional Functions,  Prev: Basic Data Structures,  Up: API

17.3 The board_state struct
===========================

A basic data structure in the engine is the `board_state' struct.  This
structure is internal to the engine and is defined in `liberty.h'.


          typedef unsigned char Intersection;

          struct board_state {
            int board_size;

            Intersection board[BOARDSIZE];
            int board_ko_pos;
            int black_captured;
            int white_captured;

            Intersection initial_board[BOARDSIZE];
            int initial_board_ko_pos;
            int initial_white_captured;
            int initial_black_captured;
            int move_history_color[MAX_MOVE_HISTORY];
            int move_history_pos[MAX_MOVE_HISTORY];
            int move_history_pointer;

            float komi;
            int move_number;
          };

   Here `Intersection' stores `EMPTY', `WHITE' or `BLACK'. It is
currently defined as an `unsigned char' to make it reasonably efficient
in both storage and access time. The board state contains an array of
`Intersection''s representing the board.  The move history is contained
in the struct. Also contained in the struct is the location of a ko
(`EMPTY') if the last move was not a ko capture, the komi, the number
of captures, and corresponding data for the initial position at the
beginning of the move history.


File: gnugo.info,  Node: Positional Functions,  Prev: The Board State,  Up: API

17.4 Functions which manipulate a Position
==========================================

All the functions in the engine that manipulate Positions have names
prefixed by `gnugo_'. These functions still use the two-dimensional
representation of the board (*note The Board Array::). Here is a
complete list, as prototyped in `gnugo.h':

   * `void init_gnugo(float memory)' 

          Initialize the gnugo engine. This needs to be called once
          only.

   * `void gnugo_clear_board(int boardsize)' 

          Clear the board.

   * `void gnugo_set_komi(float new_komi)' 

          Set the komi.

   * `void gnugo_add_stone(int i, int j, int color)' 

          Place a stone on the board

   * `void gnugo_remove_stone(int i, int j)' 

          Remove a stone from the board

   * `int gnugo_is_pass(int i, int j)' 

          Return true if (i,j) is PASS_MOVE

   * `void gnugo_play_move(int i, int j, int color)' 

          Play a move and start the clock

   * `int gnugo_undo_move(int n)' 

          Undo n permanent moves. Returns 1 if successful and 0 if it
          fails.  If n moves cannot be undone, no move is undone.

   * `int gnugo_play_sgfnode(SGFNode *node, int to_move)' 

          Perform the moves and place the stones from the SGF node on
          the board. Return the color of the player whose turn it is to
          move.

   * `int gnugo_play_sgftree(SGFNode *root, int *until, SGFNode
     **curnode)' 

          Play the moves in ROOT UNTIL movenumber is reached.  Return
          the color of the player whose turn it is to move.

   * `int gnugo_is_legal(int i, int j, int color)' 

          Interface to `is_legal()'.

   * `int gnugo_is_suicide(int i, int j, int color)' 

          Interface to `is_suicide()'.

   * `int gnugo_placehand(int handicap)' 

          Interface to placehand. Sets up handicap pieces and returns
          the number of placed handicap stones.

   * `void gnugo_recordboard(SGFNode *root)' 

          Interface to `sgffile_recordboard()'

   * `int gnugo_sethand(int handicap, SGFNode *node)' 

          Interface to placehand. Sets up handicap stones and returns
          the number of placed handicap stones, updating the sgf file

   * `int gnugo_genmove(int *i, int *j, int color)' 

          Interface to `genmove()'.

   * `int gnugo_attack(int m, int n, int *i, int *j)' 

          Interface to `attack()'.

   * `int gnugo_find_defense(int m, int n, int *i, int *j)' 

          Interface to `find_defense()'.

   * `void gnugo_who_wins(int color, FILE *outfile)' 

          Interface to `who_wins()'.

   * `float gnugo_estimate_score(float *upper, float *lower)' 

          Put upper and lower score estimates into `*upper', `*lower'
          and return the average. A positive score favors white. In
          computing the upper bound, `CRITICAL' dragons are awarded to
          white; in computing the lower bound, they are awarded to
          black.

   * `void gnugo_examine_position(int color, int how_much)' 

          Interface to `examine_position'.

   * `int gnugo_get_komi()' 

          Report the komi.

   * `void gnugo_get_board(int b[MAX_BOARD][MAX_BOARD])' 

          Place the board into the `b' array.

   * `int gnugo_get_boardsize()' 

          Report the board size.

   * `int gnugo_get_move_number()' 

          Report the move number.

17.5 Game handling
==================

The functions (in *note Positional Functions::) are all that are needed
to create a fully functional go program.  But to make the life easier
for the programmer, there is a small set of functions specially
designed for handling ongoing games.

   The data structure describing an ongoing game is the `Gameinfo'. It
is defined as follows:


     typedef struct {
       int       handicap;

       int       to_move;            /* whose move it currently is */
       SGFTree   game_record;        /* Game record in sgf format. */

       int       computer_player;    /* BLACK, WHITE, or EMPTY (used as BOTH) */

       char      outfilename[128];   /* Trickle file */
       FILE      *outfile;
     } Gameinfo;

   The meaning of `handicap' should be obvious. `to_move' is the color
of the side whose turn it is to move.

   The SGF tree `game_record' is used to store all the moves in the
entire game, including a header node which contains, among other
things, komi and handicap.

   If one or both of the opponents is the computer, the field
`computer_player' is used. Otherwise it can be ignored.

   GNU Go can use a trickle file to continuously save all the moves of
an ongoing game. This file can also contain information about internal
state of the engine such as move reasons for various locations or move
valuations. The name of this file should be stored in `outfilename' and
the file pointer to the open file is stored in `outfile'. If no trickle
file is used, `outfilename[0]' will contain a null character and
`outfile' will be set to `NULL'.

17.5.1 Functions which manipulate a Gameinfo
--------------------------------------------

All the functions in the engine that manipulate Gameinfos have names
prefixed by `gameinfo_'.  Here is a complete list, as prototyped in
`gnugo.h':

   * `void gameinfo_clear(Gameinfo *ginfo, int boardsize, float komi)' 

          Initialize the `Gameinfo' structure.

   * `void gameinfo_print(Gameinfo *ginfo)' 

          Print a gameinfo.

   * `void gameinfo_load_sgfheader(Gameinfo *gameinfo, SGFNode *head)' 

          Reads header info from sgf structure and sets the appropriate
          variables.

   * `void gameinfo_play_move(Gameinfo *ginfo, int i, int j, int color)' 

          Make a move in the game. Return 1 if the move was legal. In
          that case the move is actually done. Otherwise return 0.

   * `int gameinfo_play_sgftree_rot(Gameinfo *gameinfo, SGFNode *head,
     const char *untilstr, int orientation)' 

          Play the moves in an SGF tree. Walk the main variation,
          actioning the properties into the playing board. Returns the
          color of the next move to be made. Head is an sgf tree.
          Untilstr is an optional string of the form either 'L12' or
          '120' which tells it to stop playing at that move or move
          number. When debugging, this is the location of the move
          being examined.

   * `int gameinfo_play_sgftree(Gameinfo *gameinfo, SGFNode *head,
     const char *untilstr)' 

          Same as previous function, using standard orientation.


File: gnugo.info,  Node: Utility Functions,  Next: API,  Prev: DFA,  Up: Top

18 Utility Functions
********************

In this Chapter, we document some of the utilities which may be called
from the GNU Go engine.

* Menu:

* General Utilities::              Utilities from `engine/utils.c'
* Print Utilities::                Utilities from `engine/printutils.c'
* Board Utilities::                Utilities from `engine/board.c'
* Influence Utilities::		   Utilities from `engine/influence.c'


File: gnugo.info,  Node: General Utilities,  Next: Print Utilities,  Up: Utility Functions

18.1 General Utilities
======================

Utility functions from `engine/utils.c'. Many of these functions
underlie autohelper functions (*note Autohelper Functions::).

   * `void change_dragon_status(int dr, int status)' 

          Change the status of all the stones in the dragon at `dr'.

   * `int defend_against(int move, int color, int apos)' 

          Check whether a move at `move' stops the enemy from playing
          at (apos).

   * `int cut_possible(int pos, int color)'

          Returns true if `color' can cut at `pos', or if connection
          through `pos' is inhibited. This information is collected by
          `find_cuts()', using the B patterns in the connections
          database.

   * `int does_attack(int move, int str)' 

          returns true if the move at `move' attacks `str'. This means
          that it captures the string, and that `str' is not already
          dead.

   * `int does_defend(int move, int str)' 

          `does_defend(move, str)' returns true if the move at `move'
          defends `str'. This means that it defends the string, and that
          `str' can be captured if no defense is made.

   * `int somewhere(int color, int last_move, ...)' 

          Example: `somewhere(WHITE, 2, apos, bpos, cpos)'.  Returns
          true if one of the vertices listed satisfies
          `board[pos]==color'. Here num_moves is the number of moves
          minus one.  If the check is true the dragon is not allowed to
          be dead. This check is only valid if `stackp==0'.

   * `int visible_along_edge(int color, int apos, int bpos)'

          Search along the edge for the first visible stone. Start at
          apos and move in the direction of bpos. Return 1 if the first
          visible stone is of the given color. It is required that apos
          and bpos are at the same distance from the edge.

   * `int test_symmetry_after_move(int move, int color, int strict)' 

          Is the board symmetric (or rather antisymmetric) with respect
          to mirroring in tengen after a specific move has been played?
          If the move is PASS_MOVE, check the current board.  If strict
          is set we require that each stone is matched by a stone of
          the opposite color at the mirrored vertex. Otherwise we only
          require that each stone is matched by a stone of either color.

   * `int play_break_through_n(int color, int num_moves, ...)' 

          The function `play_break_through_n()' plays a sequence of
          moves, alternating between the players and starting with
          color. After having played through the sequence, the three
          last coordinate pairs gives a position to be analyzed by
          `break_through()', to see whether either color has managed to
          enclose some stones and/or connected his own stones. If any
          of the three last positions is empty, it's assumed that the
          enclosure has failed, as well as the attempt to connect. If
          one or more of the moves to play turns out to be illegal for
          some reason, the rest of the sequence is played anyway, and
          `break_through()' is called as if nothing special happened.
          Like `break_through()', this function returns 1 if the
          attempt to break through was succesful and 2 if it only
          managed to cut through.

   * `int play_attack_defend_n(int color, int do_attack, int num_moves,
     ...)'

   * `int play_attack_defend2_n(int color, int do_attack, int
     num_moves, ...)' 

          The function `play_attack_defend_n()' plays a sequence of
          moves, alternating between the players and starting with
          `color'. After having played through the sequence, the last
          coordinate pair gives a target to attack or defend, depending
          on the value of do_attack.  If there is no stone present to
          attack or defend, it is assumed that it has already been
          captured. If one or more of the moves to play turns out to be
          illegal for some reason, the rest of the sequence is played
          anyway, and attack/defense is tested as if nothing special
          happened. Conversely, `play_attack_defend2_n()' plays a
          sequence of moves, alternating between the players and
          starting with `color'. After having played through the
          sequence, the two last coordinate pairs give two targets to
          simultaneously attack or defend, depending on the value of
          do_attack. If there is no stone present to attack or defend,
          it is assumed that it has already been captured. If one or
          more of the moves to play turns out to be illegal for some
          reason, the rest of the sequence is played anyway, and
          attack/defense is tested as if nothing special happened.  A
          typical use of these functions is to set up a ladder in an
          autohelper and see whether it works or not.

   * `int play_connect_n(int color, int do_connect, int num_moves, ...)' 

          Plays a sequence of moves, alternating between the players
          and starting with `color'. After having played through the
          sequence, the two last coordinates give two targets that
          should be connected or disconnected, depending on the value
          of do_connect. If there is no stone present to connect or
          disconnect, it is assumed that the connection has failed. If
          one or more of the moves to play turns out to be illegal for
          some reason, the rest of the sequence is played anyway, and
          connection/disconnection is tested as if nothing special
          happened.  Ultimately the connection is decided by the
          functions `string_connect' and `disconnect' (*note Connection
          Reading::).

   * `void set_depth_values(int level)' 

          It is assumed in reading a ladder if `stackp >= depth' that
          as soon as a bounding stone is in atari, the string is safe.
          Similar uses are made of the other depth parameters such as
          `backfill_depth' and so forth. In short, simplifying
          assumptions are made when `stackp' is large. Unfortunately
          any such scheme invites the "horizon effect," in which a
          stalling move is perceived as a win, by pushing the
          refutation past the "horizon"--the value of `stackp' in which
          the reading assumptions are relaxed. To avoid the depth it is
          sometimes necessary to increase the depth parameters. This
          function can be used to set the various reading depth
          parameters. If `mandated_depth_value' is not -1 that value is
          used; otherwise the depth values are set as a function of
          level. The parameter `mandated_depth_value' can be set at the
          command line to force a particular value of depth; normally
          it is -1.

   * `void modify_depth_values(int n)' 

          Modify the various tactical reading depth parameters. This is
          typically used to avoid horizon effects. By temporarily
          increasing the depth values when trying some move, one can
          avoid that an irrelevant move seems effective just because
          the reading hits a depth limit earlier than it did when
          reading only on relevant moves.

   * `void increase_depth_values(void)' 

          `modify_depth_values(1)'.

   * `void decrease_depth_values(void)' 

          `modify_depth_values(-1)'.

   * `void restore_depth_values()' 

          Sets `depth' and so forth to their saved values.

   * `void set_temporary_depth_values(int d, int b, int b2, int bc, int
     ss, int br, int f, int k)'

          Explicitly set the depth values. This function is currently
          never called.

   * `int confirm_safety(int move, int color, int *defense_point, char
     safe_stones[BOARDMAX])' 

          Check that the move at color doesn't involve any kind of
          blunder, regardless of size.

   * `float blunder_size(int move, int color, int *defense_point, char
     safe_stones[BOARDMAX])' 

          This function will detect some blunders. If the move reduces
          the number of liberties of an adjacent friendly string, there
          is a danger that the move could backfire, so the function
          checks that no friendly worm which was formerly not
          attackable becomes attackable, and it checks that no opposing
          worm which was not defendable becomes defendable.  It returns
          the estimated size of the blunder, or 0.0 if nothing bad has
          happened.  The array `safe_stones[]' contains the stones that
          are supposedly safe after `move'. It may be `NULL'. For use
          when called from `fill_liberty()', this function may
          optionally return a point of defense, which, if taken, will
          presumably make the move at `move' safe on a subsequent turn.

   * `int double_atari(int move, int color, float *value, char
     safe_stones[BOARDMAX])' 

          Returns true if a move by (color) fits the following shape:
                   X*        (O=color)
                   OX
          capturing one of the two `X' strings. The name is a slight
          misnomer since this includes attacks which are not
          necessarily double ataris, though the common double atari is
          the most important special case. If `safe_stones != NULL',
          then only attacks on stones marked as safe are tried. The
          value of the double atari attack is returned in value (unless
          value is `NULL'), and the attacked stones are marked unsafe.

   * `void unconditional_life(int unconditional_territory[BOARDMAX],
     int color)' 

          Find those worms of the given color that can never be
          captured, even if the opponent is allowed an arbitrary number
          of consecutive moves. The coordinates of the origins of these
          worms are written to the worm arrays and the number of
          non-capturable worms is returned.  The algorithm is to cycle
          through the worms until none remains or no more can be
          captured. A worm is removed when it is found to be
          capturable, by letting the opponent try to play on all its
          liberties. If the attack fails, the moves are undone. When no
          more worm can be removed in this way, the remaining ones are
          unconditionally alive.  After this, unconditionally dead
          opponent worms and unconditional territory are identified. To
          find these, we continue from the position obtained at the end
          of the previous operation (only unconditionally alive strings
          remain for color) with the following steps:

            1. Play opponent stones on all liberties of the
               unconditionally alive strings except where illegal.
               (That the move order may determine exactly which
               liberties can be played legally is not important. Just
               pick an arbitrary order).

            2. Recursively extend opponent strings in atari, except
               where this would be suicide.

            3. Play an opponent stone anywhere it can get two empty
               neighbors. (I.e. split big eyes into small ones).

            4. an opponent stone anywhere it can get one empty
               neighbor. (I.e. reduce two space eyes to one space eyes.)
               Remaining opponent strings in atari and remaining
               liberties of the unconditionally alive strings
               constitute the unconditional territory.  Opponent
               strings from the initial position placed on
               unconditional territory are unconditionally dead.  On
               return, `unconditional_territory[][]' is 1 where color
               has unconditionally alive stones, 2 where it has
               unconditional territory, and 0 otherwise.

   * `void who_wins(int color, FILE *outfile)'

          Score the game and determine the winner

   * `void find_superstring(int str, int *num_stones, int *stones)' 

          Find the stones of an extended string, where the extensions
          are through the following kinds of connections:
            1. Solid connections (just like ordinary string).
                        OO

            2. Diagonal connection or one space jump through an
               intersection where an opponent move would be suicide or
               self-atari.
                        ...
                        O.O
                        XOX
                        X.X

            3. Bamboo joint.
                        OO
                        ..
                        OO

            4. Diagonal connection where both adjacent intersections
               are empty.
                        .O
                        O.

            5. Connection through adjacent or diagonal tactically
               captured stones.  Connections of this type are omitted
               when the superstring code is called from reading.c, but
               included when the superstring code is called from owl.c

   * `void find_superstring_liberties(int str, int *num_libs, int
     *libs, int liberty_cap)' 

          This function computes the superstring at `str' as described
          above, but omitting connections of type 5. Then it constructs
          a list of liberties of the superstring which are not already
          liberties of `str'.  If `liberty_cap' is nonzero, only
          liberties of substrings of the superstring which have fewer
          than `liberty_cap' liberties are generated.

   * `void find_proper_superstring_liberties(int str, int *num_libs,
     int *libs, int liberty_cap)' 

          This function is the same as find_superstring_liberties, but
          it omits those liberties of the string `str', presumably
          since those have already been treated elsewhere.  If
          `liberty_cap' is nonzero, only liberties of substrings of the
          superstring which have at most `liberty_cap' liberties are
          generated.

   * `void find_superstring_stones_and_liberties(int str, int
     *num_stones, int *stones, int *num_libs, int *libs, int
     liberty_cap)' 

          This function computes the superstring at `str' as described
          above, but omitting connections of type 5. Then it constructs
          a list of liberties of the superstring which are not already
          liberties of `str'. If liberty_cap is nonzero, only liberties
          of substrings of the superstring which have fewer than
          liberty_cap liberties are generated.

   * `void superstring_chainlinks(int str, int *num_adj, int
     adjs[MAXCHAIN], int liberty_cap)' 

          analogous to chainlinks, this function finds boundary chains
          of the superstring at `str', including those which are
          boundary chains of `str' itself. If `liberty_cap != 0', only
          those boundary chains with `<= liberty_cap' liberties are
          reported.

   * `void proper_superstring_chainlinks(int str, int *num_adj, int
     adjs[MAXCHAIN], int liberty_cap)' 

          analogous to chainlinks, this function finds boundary chains
          of the superstring at `str', omitting those which are
          boundary chains of `str' itself. If `liberty_cap != 0', only
          those boundary chains with `<= liberty_cap' liberties are
          reported.

   * `void start_timer(int n)' 

          Start a timer. GNU Go has four internal timers available for
          assessing the time spent on various tasks.

   * `double time_report(int n, const char *occupation, int move,
     double mintime)' 

          Report time spent and restart the timer. Make no report if
          elapsed time is less than mintime.


File: gnugo.info,  Node: Print Utilities,  Next: Board Utilities,  Prev: General Utilities,  Up: Utility Functions

18.2 Print Utilities
====================

Functions in `engine/printutils.c' do formatted printing similar to
`printf' and its allies.  The following formats are recognized:

   * `%c', `%d', `%f', `%s', `%x'

          These have their usual meaning in formatted output, printing
          a character, integer, float, string or hexadecimal,
          respectively.

   * `%o'

          `Outdent.' Normally output is indented by `2*stackp' spaces,
          so that the depth can be seen at a glance in traces. At the
          beginning of a format, this `%o' inhibits the indentation.

   * `%H'

          Print a hashvalue.

   * `%C'

          Print a color as a string.

   * `%m', `%2m' (synonyms)

          Takes 2 integers and writes a move, using the two dimensional
          board representation (*note The Board Array::)

   * `%1m'

          Takes 1 integers and writes a move, using the one dimensional
          board representation (*note The Board Array::)

   We list the non statically declared functions in `printutils.c'.

   * `void gfprintf(FILE *outfile, const char *fmt, ...)' 

          Formatted output to `outfile'.

   * `int gprintf(const char *fmt, ...)' 

          Formatted output to stderr. Always returns 1 to allow use in
          short-circuit logical expressions.

   * `int mprintf(const char *fmt, ...)' 

          Formatted output to stdout.

   * `DEBUG(level, fmt, args...)' 

          If `level & debug', do formatted output to stderr. Otherwise,
          ignore.

   * `void abortgo(const char *file, int line, const char *msg, int
     pos)' 

          Print debugging output in an error situation, then exit.

   * `const char * color_to_string(int color)' 

          Convert a color value to a string

   * `const char * location_to_string(int pos)' 

          Convert a location to a string

   * `void location_to_buffer(int pos, char *buf)' 

          Convert a location to a string, writing to a buffer.

   * `int string_to_location(int boardsize, char *str, int *m, int *n)' 

          Get the `(m, n)' coordinates in the standard GNU Go
          coordinate system from the string `str'.  This means that `m'
          is the nth row from the top and `n' is the column. Both
          coordinates are between 0 and `boardsize-1', inclusive.
          Return 1 if ok, otherwise return 0;

   * `int is_hoshi_point(int m, int n)' True if the coordinate is a
     hoshi point.

   * `void draw_letter_coordinates(FILE *outfile)' Print a line with
     coordinate letters above the board.

   * `void simple_showboard(FILE *outfile)' 

          Bare bones version of `showboard(0)'. No fancy options, no
          hint of color, and you can choose where to write it.

   The following functions are in `showbord.c'. Not all public
functions in that file are listed here.

   * `void showboard(int xo)' 

          Show go board.
               xo=0:      black and white XO board for ascii game
               xo=1:      colored dragon display
               xo=2:      colored eye display
               xo=3:      colored owl display
               xo=4:      colored matcher status display

   * `const char * status_to_string(int status)' 

          Convert a status value to a string.

   * `const char * safety_to_string(int status)' 

          Convert a safety value to a string.

   * `const char * result_to_string(int result)' 

          Convert a read result to a string


File: gnugo.info,  Node: Board Utilities,  Next: Influence Utilities,  Prev: Print Utilities,  Up: Utility Functions

18.3 Board Utilities
====================

The functions documented in this section are from `board.c'. Other
functions in `board.c' are described in *Note Some Board Functions::.

   * `void store_board(struct board_state *state)' 

          Save board state.

   * `void restore_board(struct board_state *state)' 

          Restore a saved board state.

   * `void clear_board(void)' 

          Clear the internal board.

   * `void dump_stack(void)' 

          for use under gdb prints the move stack.

   * `void add_stone(int pos, int color)' 

          Place a stone on the board and update the board_hash. This
          operation destroys all move history.

   * `void remove_stone(int pos)' 

          Remove a stone from the board and update the board_hash. This
          operation destroys the move history.

   * `int is_pass(int pos)' 

          Test if the move is a pass or not.  Return 1 if it is.

   * `int  is_legal(int pos, int color)' 

          Determines whether the move `color' at `pos' is legal.

   * `int  is_suicide(int pos, int color)' 

          Determines whether the move `color' at `pos' would be a
          suicide.  This is the case if
            1. There is no neighboring empty intersection.

            2. There is no neighboring opponent string with exactly one
               liberty.

            3. There is no neighboring friendly string with more than
               one liberty.

   * `int is_illegal_ko_capture(int pos, int color)' 

          Determines whether the move `color' at `pos' would be an
          illegal ko capture.

   * `int is_edge_vertex(int pos)' 

          Determine whether vertex is on the edge.

   * `int edge_distance(int pos)' 

          Distance to the edge.

   * `int is_corner_vertex(int pos)' 

          Determine whether vertex is a corner.

   * `int get_komaster()' 

   * `int get_kom_pos()' 

          Public functions to access the variable `komaster' and
          `kom_pos', which are static in `board.c'.

   Next we come to `countlib()' and its allies, which address the
problem of determining how many liberties a string has. Although
`countlib()' addresses this basic question, other functions can often
get the needed information more quickly, so there are a number of
different functions in this family.

   * `int countlib(int str)' 

          Count the number of liberties of the string at `pos'. There
          must be a stone at this location.

   * `int findlib(int str, int maxlib, int *libs)' 

          Find the liberties of the string at `str'. This location must
          not be empty. The locations of up to maxlib liberties are
          written into `libs[]'. The full number of liberties is
          returned.  If you want the locations of all liberties,
          whatever their number, you should pass `MAXLIBS' as the value
          for `maxlib' and allocate space for `libs[]' accordingly.

   * `int fastlib(int pos, int color, int ignore_captures)' 

          Count the liberties a stone of the given color would get if
          played at `pos'. The intent of this function is to be as fast
          as possible, not necessarily complete. But if it returns a
          positive value (meaning it has succeeded), the value is
          guaranteed to be correct. Captures are ignored based if the
          `ignore_captures' field is nonzero. The location `pos' must
          be empty.  The function fails if there are more than two
          neighbor strings of the same color.  In this case, the return
          value is -1.  Captures are handled in a very limited way, so
          if ignore_capture is 0, and a capture is required, it will
          often return -1.

   * `int approxlib(int pos, int color, int maxlib, int *libs)' 

          Find the liberties a stone of the given color would get if
          played at `pos', ignoring possible captures of opponent
          stones.  The location `pos' must be empty. If `libs != NULL',
          the locations of up to `maxlib' liberties are written into
          `libs[]'. The counting of liberties may or may not be halted
          when `maxlib' is reached. The number of liberties found is
          returned, which may be less than the total number of
          liberties if `maxlib' is small. If you want the number or the
          locations of all liberties, however many they are, you should
          pass `MAXLIBS' as the value for maxlib and allocate space for
          `libs[]' accordingly.

   * `int accuratelib(int pos, int color, int maxlib, int *libs)' 

          Find the liberties a stone of the given color would get if
          played at `pos'. This function takes into consideration all
          captures. Its return value is exact in that sense it counts
          all the liberties, unless `maxlib' allows it to stop earlier.
          The location `pos' must be empty. If `libs != NULL', the
          locations of up to `maxlib' liberties are written into
          `libs[]'. The counting of liberties may or may not be halted
          when `maxlib' is reached. The number of found liberties is
          returned.  This function guarantees that liberties which are
          not results of captures come first in `libs[]' array. To find
          whether all the liberties starting from a given one are
          results of captures, one may use `if (board[libs[k]] !=
          EMPTY)' construction.  If you want the number or the
          locations of all liberties, however many they are, you should
          pass `MAXLIBS' as the value for `maxlib' and allocate space
          for `libs[]' accordingly.

   Next we have some general utility functions.

   * `int count_common_libs(int str1, int str2)' 

          Find the number of common liberties of the two strings.

   * `int find_common_libs(int str1, int str2, int maxlib, int *libs)' 

          Find the common liberties of the two strings. The locations
          of up to `maxlib' common liberties are written into `libs[]'.
          The full number of common liberties is returned.  If you want
          the locations of all common liberties, whatever their number,
          you should pass `MAXLIBS' as the value for `maxlib' and
          allocate space for `libs[]' accordingly.

   * `int have_common_lib(int str1, int str2, int *lib)' 

          Determine whether two strings have at least one common
          liberty.  If they do and `lib != NULL', one common liberty is
          returned in `*lib'.

   * `int countstones(int str)' 

          Report the number of stones in a string.

   * `int findstones(int str, int maxstones, int *stones)' 

          Find the stones of the string at `str'. The location must not
          be empty. The locations of up to maxstones stones are written
          into `stones[]'. The full number of stones is returned.

   * `int  chainlinks(int str, int adj[MAXCHAIN])' 

          This very useful function returns (in the `adj' array) the
          chains surrounding the string at `str'. The number of chains
          is returned.

   * `int chainlinks2(int str, int adj[MAXCHAIN], int lib)' 

          Returns (in `adj' array) those chains surrounding the string
          at `str', which has exactly `lib' liberties. The number of
          such chains is returned.

   * `int chainlinks3(int str, int adj[MAXCHAIN], int lib)' 

          Returns (in `adj' array) the chains surrounding the string at
          `str', which have less or equal `lib' liberties.  The number
          of such chains is returned.

   * `int extended_chainlinks(int str, int adj[MAXCHAIN], int
     both_colors)' 

          Returns (in the `adj' array) the opponent strings being
          directly adjacent to `str' or having a common liberty with
          `str'. The number of such strings is returned.  If the
          both_colors parameter is true, also own strings sharing a
          liberty are returned.

   * `int find_origin(int str)' 

          Find the origin of a string, i.e. the point with the smallest
          1D board coordinate. The idea is to have a canonical
          reference point for a string.

   * `int is_self_atari(int pos, int color)' 

          Determine whether a move by color at `pos' would be a self
          atari, i.e. whether it would get more than one liberty. This
          function returns true also for the case of a suicide move.

   * `int liberty_of_string(int pos, int str)' 

          Returns true if `pos' is a liberty of the string at `str'.

   * `int second_order_liberty_of_string(int pos, int str)' 

          Returns true if `pos' is a second order liberty of the string
          at str.

   * `int neighbor_of_string(int pos, int str)' 

          Returns true if `pos' is adjacent to the string at `str'.

   * `int has_neighbor(int pos, int color)' 

          Returns true if `pos' has a neighbor of `color'.

   * `int same_string(int str1, int str2)' 

          Returns true if `str1' and `str2' belong to the same string.

   * `int adjacent_strings(int str1, int str2)' 

          Returns true if the strings at `str1' and `str2' are adjacent.

   * `int is_ko(int pos, int color, int *ko_pos)' 

          Return true if the move `pos' by `color' is a ko capture
          (whether capture is legal on this move or not). If so, and if
          `ko_pos' is not a `NULL' pointer, then `*ko_pos' returns the
          location of the captured ko stone.  If the move is not a ko
          capture, `*ko_pos' is set to 0.  A move is a ko capture if
          and only if
            1. All neighbors are opponent stones.

            2. The number of captured stones is exactly one.

   * `int is_ko_point(int pos)' 

          Return true if `pos' is either a stone, which if captured
          would give ko, or if `pos' is an empty intersection adjacent
          to a ko stone.

   * `int does_capture_something(int pos, int color)' 

          Returns 1 if at least one string is captured when color plays
          at `pos'.

   * `void mark_string(int str, char mx[BOARDMAX], char mark)' 

          For each stone in the string at pos, set `mx' to value mark.
          If some of the stones in the string are marked prior to
          calling this function, only the connected unmarked stones
          starting from pos are guaranteed to become marked. The rest
          of the string may or may not become marked. (In the current
          implementation, it will.)

   * `int move_in_stack(int pos, int cutoff)' 

          Returns true if at least one move has been played at pos at
          deeper than level `cutoff' in the reading tree.

   * `int stones_on_board(int color)' 

          Return the number of stones of the indicated color(s) on the
          board.  This only counts stones in the permanent position,
          not stones placed by `trymove()' or `tryko()'. Use
          `stones_on_board(BLACK | WHITE)' to get the total number of
          stones on the board.


File: gnugo.info,  Node: Influence Utilities,  Prev: Board Utilities,  Up: Utility Functions

18.4 Utilities from `engine/influence.c'
========================================

We will only list here a portion of the public functions in
`influence.c'.  The influence code is invoked through the function
`compute_influence' (*note Influence Usage::). It is invoked as follows.

   * `void compute_influence(int color, const char
     safe_stones[BOARDMAX], const float strength[BOARDMAX], struct
     influence_data *q, int move, const char *trace_message)' 

          Compute the influence values for both colors.  The caller must
             - set up the `board[]' state

             - mark safe stones with `INFLUENCE_SAFE_STONE', dead
               stones with 0

             - mark stones newly saved by a move with
               `INFLUENCE_SAVED_STONE' (this is relevant if the
               influence_data *q is reused to compute a followup value
               for this move).
          Results will be stored in q.  `move' has no effects except
          toggling debugging. Set it to -1 for no debug output at all
          (otherwise it will be controlled by the `-m' command line
          option). It is assumed that `color' is in turn to move. (This
          affects the barrier patterns (class A, D) and intrusions
          (class B)). Color

   Other functions in `influence.c' are of the nature of utilities
which may be useful throughout the engine. We list the most useful ones
here.

   * `void influence_mark_non_territory(int pos, int color)' 

          Called from actions for `t' patterns in `barriers.db'.  Marks
          `pos' as not being territory for `color'.

   * `int whose_territory(const struct influence_data *q, int pos)' 

          Return the color of the territory at `pos'. If it's territory
          for neither color, `EMPTY' is returned.

   * `int whose_moyo(const struct influence_data *q, int pos)' 

          Return the color who has a moyo at `pos'. If neither color
          has a moyo there, `EMPTY' is returned. The definition of moyo
          in terms of the influences is totally ad hoc.

   * `int whose_area(const struct influence_data *q, int pos)' 

          Return the color who has dominating influence ("area") at
          `pos'.  If neither color dominates the influence there, EMPTY
          is returned.  The definition of area in terms of the
          influences is totally ad hoc.


File: gnugo.info,  Node: GTP,  Next: Regression,  Prev: API,  Up: Top

19 The Go Text Protocol
***********************

* Menu:

* The Go Text Protocol::          The Go Text Protocol
* Running in GTP mode::           Running GNU Go in GTP mode
* GTP applications::              GTP applications
* The Metamachine::               The Metamachine
* Adding new GTP commands::       Adding new GTP commands
* GTP command reference::         Details on every GTP command


File: gnugo.info,  Node: The Go Text Protocol,  Next: Running in GTP mode,  Up: GTP

19.1 The Go Text Protocol
=========================

GNU Go 3.0 introduced a new interface, the Go Text Protocol, abbreviated
GTP. The intention was to make an interface that is better suited for
machine-machine communication than the ascii interface and simpler, more
powerful, and more flexible than the Go Modem Protocol.

   There are two versions of the protocol. Version 1 was used with GNU
Go 3.0 and 3.2. GNU Go 3.4 and later versions use protocol version 2.
The specification of GTP version 2 is available at
`http://www.lysator.liu.se/~gunnar/gtp/'. GNU Go 3.4 is the reference
implementation for GTP version 2, but all but the most common commands
are to be regarded as private extensions of the protocol.

   The GTP has a variety of applications. For GNU Go the first use was
in regression testing (*note Regression::), followed by communication
with the NNGS go server and for automated test games against itself and
other programs. Now there are also many graphical user interfaces
available supporting GTP, as well as bridges to other Go servers than
NNGS.


File: gnugo.info,  Node: Running in GTP mode,  Next: GTP applications,  Prev: The Go Text Protocol,  Up: GTP

19.2 Running GNU Go in GTP mode
===============================

To start GNU Go in GTP mode, simply invoke it with the option `--mode
gtp'. You will not get a prompt or any other output to start with but
GNU Go is silently waiting for GTP commands.

   A sample GTP session may look as follows:

     virihaure 462% ./gnugo --mode gtp
     1 boardsize 7
     =1

     2 clear_board
     =2

     3 play black D5
     =3

     4 genmove white
     =4 C3

     5 play black C3
     ?5 illegal move

     6 play black E3
     =6

     7 showboard
     =7
        A B C D E F G
      7 . . . . . . . 7
      6 . . . . . . . 6
      5 . . + X + . . 5
      4 . . . + . . . 4
      3 . . O . X . . 3
      2 . . . . . . . 2     WHITE (O) has captured 0 stones
      1 . . . . . . . 1     BLACK (X) has captured 0 stones
        A B C D E F G

     8 quit
     =8

   Commands are given on a single line, starting by an optional identity
number, followed by the command name and its arguments.

   If the command is successful, the response starts by an equals sign
(`='), followed by the identity number of the command (if any) and then
the result. In this example all results were empty strings except for
command 4 where the answer was the white move at C3, and command 7
where the result was a diagram of the current board position. The
response ends by two consecutive newlines.

   Failing commands are signified by a question mark (`?') instead of
an equals sign, as in the response to command 5.

   The detailed specification of the protocol can be found at
`http://www.lysator.liu.se/~gunnar/gtp/'. The available commands in GNU
Go may always be listed using the command `list_commands'.  They are
also documented in *Note GTP command reference::.


File: gnugo.info,  Node: GTP applications,  Next: The Metamachine,  Prev: Running in GTP mode,  Up: GTP

19.3 GTP applications
=====================

GTP is an asymmetric protocol involving two parties which we call
controller and engine. The controller sends all commands and the engine
only responds to these commands. GNU Go implements the engine end of the
protocol.

   With the source code of GNU Go is also distributed a number of
applications implementing the controller end. Among the most
interesting of these are:

   * `regression/regress.awk'

          Script to run regressions. The script sends GTP commands to
          set up and evaluate positions to the engine and then analyzes
          the responses from the engine. More information about GTP
          based regression testing can be found in the regression
          chapter (*note Regression::).

   * `regression/regress.pl'

          Perl script to run regressions, giving output which together
          with the CGI script `regression/regress.plx' generates HTML
          views of the regressions.

   * `regression/regress.pike'

          Pike script to run regressions. More feature-rich and
          powerful than `regress.awk'.

   * `regression/view.pike'

          Pike script to examine a single regression testcase through a
          graphical board. This gives an easy way to inspect many of
          the GNU Go internals.

   * `interface/gtp_examples/twogtp'

          Perl script to play two engines against each other. The script
          essentially sets up both engines with desired boardsize,
          handicap, and komi, then relays moves back and forth between
          the engines.

   * `interface/gtp_examples/twogtp-a'

          An alternative Perl implementation of twogtp.

   * `interface/gtp_examples/twogtp.py'

          Implementation of twogtp in Python. Has more features than
          the Perl variants.

   * `interface/gtp_examples/twogtp.pike'

          Implementation of twogtp in Pike. Has even more features than
          the Python variant.

   * `interface/gtp_examples/2ptkgo.pl'

          Variation of twogtp which includes a graphical board.

   More GTP applications, including bridges to go servers and graphical
user interfaces, are listed at `http://www.lysator.liu.se/~gunnar/gtp/'.


File: gnugo.info,  Node: The Metamachine,  Next: Adding new GTP commands,  Prev: GTP applications,  Up: GTP

19.4 The Metamachine
====================

An interesting application of the GTP is the concept of using GNU Go as
an "Oracle" that can be consulted by another process. This could be
another computer program that asks GNU Go to generate future board
positions, then evaluate them.

   David Doshay at the University of California at Santa Cruz has done
interesting experiments with a parallel engine, known as SlugGo, that
is based on GNU Go.  These are described in
`http://lists.gnu.org/archive/html/gnugo-devel/2004-08/msg00060.html'.

   The "Metamachine" experiment is a more modest approach using the GTP
to communicate with a GNU Go process that is used as an oracle. The
following scheme is used.

   * The GNU Go "oracle" is asked to generate its top moves using the
     GTP `top_moves' commands.

   * Both moves are tried and `estimate_score' is called from the
     resulting board position.

   * The higher scoring position is selected as the engine's move.

   This scheme does not produce a stronger engine, but it is
suggestive, and the SlugGo experiment seems to show that a more
elaborate scheme along the same lines could produce a stronger engine.

   Two implementations are distributed with GNU Go. Both make use of
`fork' and `pipe' system calls, so they require a Unix-like
environment.  The Metamachine has been tested under GNU/Linux.

   *Important:* If the Metamachine terminates normally, the GNU Go
process will be killed. However there is a danger that something will
go wrong. When you are finished running the Metamachine, it is a good
idea to run `ps -A|grep gnugo' or `ps -aux|grep gnugo' to make sure
there are no unterminated processes. (If there are, just kill them.)

19.4.1 The Standalone Metamachine
---------------------------------

In `interface/gtp_examples/metamachine.c' is a standalone
implementation of the Metamachine. Compile it with `cc -o metamachine
metamachine.c' and run it. It forks a `gnugo' process with which it
communicates through the GTP, to use as an oracle.

   The following scheme is followed:

                  stdin             pipe a
       GTP client ----> Metamachine -----> GNU Go
                  <----             <-----
                 stdout             pipe b

   Most commands issued by the client are passed along verbatim to GNU
Go by the Metamachine. The exception is gg_genmove, which is
intercepted then processed differently, as described above. The client
is unaware of this, and only knows that it issued a gg_genmove command
and received a reply.  Thus to the the Metamachine appears as an
ordinary GTP engine.

   Usage: no arguments gives normal GTP behavior.  `metamachine
--debug' sends diagnostics to stderr.

19.4.2 GNU Go as a Metamachine
------------------------------

Alternatively, you may compile GNU Go with the configure option
`--enable-metamachine'. This causes the file `oracle.c' to be compiled,
which contains the Metamachine code. This has no effect on the engine
unless you run GNU Go with the runtime option `--metamachine'. Thus you
must use both the configure and the runtime option to get the
Metamachine.

   This method is better than the standalone program since you have
access to GNU Go's facilities. For example, you can run the Metamachine
with CGoban or in Ascii mode this way.

   You can get traces by adding the command line `-d0x1000000'. In
debugging the Metamachine, a danger is that any small oversight in
designing the program can cause the forked process and the controller
to hang, each one waiting for a response from the other. If this seems
to happen it is useful to know that you can attach `gdb' to a running
process and find out what it is doing.


File: gnugo.info,  Node: Adding new GTP commands,  Next: GTP command reference,  Prev: The Metamachine,  Up: GTP

19.5 Adding new GTP commands
============================

The implementation of GTP in GNU Go is distributed over three files,
`interface/gtp.h', `interface/gtp.c', and `interface/play_gtp.c'. The
first two implement a small library of helper functions which can be
used also by other programs. In the interest of promoting the GTP they
are licensed with minimal restrictions (*note GTP License::). The
actual GTP commands are implemented in `play_gtp.c', which has
knowledge about the engine internals.

   To see how a simple but fairly typical command is implemented we
look at `gtp_countlib()' (a GNU Go private extension command):

     static int
     gtp_countlib(char *s)
     {
       int i, j;
       if (!gtp_decode_coord(s, &i, &j))
         return gtp_failure("invalid coordinate");

       if (BOARD(i, j) == EMPTY)
         return gtp_failure("vertex must not be empty");

       return gtp_success("%d", countlib(POS(i, j)));
     }

   The arguments to the command are passed in the string `s'. In this
case we expect a vertex as argument and thus try to read it with
`gtp_decode_coord()' from `gtp.c'.

   A correctly formatted response should start with either `=' or `?',
followed by the identity number (if one was sent), the actual result,
and finally two consecutive newlines. It is important to get this
formatting correct since the controller in the other end relies on it.
Naturally the result itself cannot contain two consecutive newlines but
it may be split over several lines by single newlines.

   The easiest way to generate a correctly formatted response is with
one of the functions `gtp_failure()' and `gtp_success()', assuming that
their formatted output does not end with a newline.

   Sometimes the output is too complex for use with gtp_success, e.g. if
we want to print vertices, which gtp_success() does not support. Then
we have to fall back to the construction in e.g.  `gtp_genmove()':

     static int
     gtp_genmove(char *s)
     {
       [...]
       gtp_start_response(GTP_SUCCESS);
       gtp_print_vertex(i, j);
       return gtp_finish_response();
     }

   Here `gtp_start_response()' writes the equal sign and the identity
number while `gtp_finish_response()' adds the final two newlines.  The
next example is from `gtp_list_commands()':

     static int
     gtp_list_commands(char *s)
     {
       int k;
       UNUSED(s);

       gtp_start_response(GTP_SUCCESS);

       for (k = 0; commands[k].name != NULL; k++)
         gtp_printf("%s\n", commands[k].name);

       gtp_printf("\n");
       return GTP_OK;
     }

   As we have said, the response should be finished with two newlines.
Here we have to finish up the response ourselves since we already have
one newline in place from the last command printed in the loop.

   In order to add a new GTP command to GNU Go, the following pieces of
code need to be inserted in `play_gtp.c':
  1. A function declaration using the `DECLARE' macro in the list
     starting at line 68.

  2. An entry in the `commands[]' array starting at line 200.

  3. An implementation of the function handling the command.

   Useful helper functions in `gtp.c'/`gtp.h' are:
   * `gtp_printf()' for basic formatted printing.

   * `gtp_mprintf()' for printing with special format codes for
     vertices and colors.

   * `gtp_success()' and `gtp_failure()' for simple responses.

   * `gtp_start_response()' and `gtp_end_response()' for more complex
     responses.

   * `gtp_print_vertex()' and `gtp_print_vertices()' for printing one
     or multiple vertices.

   * `gtp_decode_color()' to read in a color from the command arguments.

   * `gtp_decode_coord()' to read in a vertex from the command
     arguments.

   * `gtp_decode_move()' to read in a move, i.e. color plus vertex,
     from the command arguments.


File: gnugo.info,  Node: GTP command reference,  Prev: Adding new GTP commands,  Up: GTP

19.6 GTP command reference
==========================

This section lists the GTP commands implemented in GNU Go along with
some information about each command. Each entry in the list has the
following fields:

   * Function: What this command does.

   * Arguments: What other information, if any, this command requires.
     Typical values include "none" or "vertex" or "integer" (there are
     others).

   * Fails: Circumstances which cause this command to fail.

   * Returns: What is displayed after the "=" and before the two
     newlines.  Typical values include "nothing" or "a move coordinate"
     or some status string (there are others).

   * Status: How this command relates to the standard GTP version 2
     commands. If nothing else is specified it is a GNU Go private
     extension.

   Without further ado, here is the big list (in no particular order):

   * quit


           Function:  Quit
           Arguments: none
           Fails:     never
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * protocol_version


           Function:  Report protocol version.
           Arguments: none
           Fails:     never
           Returns:   protocol version number

           Status:    GTP version 2 standard command.

   * name


           Function:  Report the name of the program.
           Arguments: none
           Fails:     never
           Returns:   program name

           Status:    GTP version 2 standard command.

   * version


           Function:  Report the version number of the program.
           Arguments: none
           Fails:     never
           Returns:   version number

           Status:    GTP version 2 standard command.

   * boardsize


           Function:  Set the board size to NxN and clear the board.
           Arguments: integer
           Fails:     board size outside engine's limits
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * query_boardsize


           Function:  Find the current boardsize
           Arguments: none
           Fails:     never
           Returns:   board_size

   * clear_board


           Function:  Clear the board.
           Arguments: none
           Fails:     never
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * orientation


           Function:  Set the orienation to N and clear the board
           Arguments: integer
           Fails:     illegal orientation
           Returns:   nothing

   * query_orientation


           Function:  Find the current orientation
           Arguments: none
           Fails:     never
           Returns:   orientation

   * komi


           Function:  Set the komi.
           Arguments: float
           Fails:     incorrect argument
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * get_komi


           Function:  Get the komi
           Arguments: none
           Fails:     never
           Returns:   Komi

   * black


           Function:  Play a black stone at the given vertex.
           Arguments: vertex
           Fails:     invalid vertex, illegal move
           Returns:   nothing

           Status:    Obsolete GTP version 1 command.

   * playwhite


           Function:  Play a white stone at the given vertex.
           Arguments: vertex
           Fails:     invalid vertex, illegal move
           Returns:   nothing

           Status:    Obsolete GTP version 1 command.

   * play


           Function:  Play a stone of the given color at the given vertex.
           Arguments: color, vertex
           Fails:     invalid vertex, illegal move
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * fixed_handicap


           Function:  Set up fixed placement handicap stones.
           Arguments: number of handicap stones
           Fails:     invalid number of stones for the current boardsize
           Returns:   list of vertices with handicap stones

           Status:    GTP version 2 standard command.

   * place_free_handicap


           Function:  Choose free placement handicap stones and put them on the board.
           Arguments: number of handicap stones
           Fails:     invalid number of stones
           Returns:   list of vertices with handicap stones

           Status:    GTP version 2 standard command.

   * set_free_handicap


           Function:  Put free placement handicap stones on the board.
           Arguments: list of vertices with handicap stones
           Fails:     board not empty, bad list of vertices
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * get_handicap


           Function:  Get the handicap
           Arguments: none
           Fails:     never
           Returns:   handicap

   * loadsgf


           Function:  Load an sgf file, possibly up to a move number or the first
                      occurence of a move.
           Arguments: filename + move number, vertex, or nothing
           Fails:     missing filename or failure to open or parse file
           Returns:   color to play

           Status:    GTP version 2 standard command.

   * color


           Function:  Return the color at a vertex.
           Arguments: vertex
           Fails:     invalid vertex
           Returns:   "black", "white", or "empty"

   * list_stones


           Function:  List vertices with either black or white stones.
           Arguments: color
           Fails:     invalid color
           Returns:   list of vertices

   * countlib


           Function:  Count number of liberties for the string at a vertex.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   Number of liberties.

   * findlib


           Function:  Return the positions of the liberties for the string at a vertex.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   Sorted space separated list of vertices.

   * accuratelib


           Function:  Determine which liberties a stone of given color
                      will get if played at given vertex.
           Arguments: move (color + vertex)
           Fails:     invalid color, invalid vertex, occupied vertex
           Returns:   Sorted space separated list of liberties

   * accurate_approxlib


           Function:  Determine which liberties a stone of given color
                      will get if played at given vertex.
           Arguments: move (color + vertex)
           Fails:     invalid color, invalid vertex, occupied vertex
           Returns:   Sorted space separated list of liberties

           Supposedly identical in behavior to the above function and
           can be retired when this is confirmed.

   * is_legal


           Function:  Tell whether a move is legal.
           Arguments: move
           Fails:     invalid move
           Returns:   1 if the move is legal, 0 if it is not.

   * all_legal


           Function:  List all legal moves for either color.
           Arguments: color
           Fails:     invalid color
           Returns:   Sorted space separated list of vertices.

   * captures


           Function:  List the number of captures taken by either color.
           Arguments: color
           Fails:     invalid color
           Returns:   Number of captures.

   * last_move


           Function:  Return the last move.
           Arguments: none
           Fails:     no previous move known
           Returns:   Color and vertex of last move.

   * move_history


           Function:  Print the move history in reverse order
           Arguments: none
           Fails:     never
           Returns:   List of moves played in reverse order in format:
                      color move (one move per line)

   * trymove


           Function:  Play a stone of the given color at the given vertex.
           Arguments: move (color + vertex)
           Fails:     invalid color, invalid vertex, illegal move
           Returns:   nothing

   * tryko


           Function:  Play a stone of the given color at the given vertex,
                      allowing illegal ko capture.
           Arguments: move (color + vertex)
           Fails:     invalid color, invalid vertex, illegal move
           Returns:   nothing

   * popgo


           Function:  Undo a trymove or tryko.
           Arguments: none
           Fails:     stack empty
           Returns:   nothing

   * clear_cache


           Function:  clear the caches.
           Arguments: none.
           Fails:     never.
           Returns:   nothing.

   * attack


           Function:  Try to attack a string.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   attack code followed by attack point if attack code nonzero.

   * attack_either


           Function:  Try to attack either of two strings
           Arguments: two vertices
           Fails:     invalid vertex, empty vertex
           Returns:   attack code against the strings.  Guarantees there
                      exists a move which will attack one of the two
                      with attack_code, but does not return the move.

   * defend


           Function:  Try to defend a string.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   defense code followed by defense point if defense code nonzero.

   * ladder_attack


           Function:  Try to attack a string strictly in a ladder.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   attack code followed by attack point if attack code nonzero.

   * increase_depths


           Function:  Increase depth values by one.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * decrease_depths


           Function:  Decrease depth values by one.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * owl_attack


           Function:  Try to attack a dragon.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   attack code followed by attack point if attack code nonzero.

   * owl_defend


           Function:  Try to defend a dragon.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   defense code followed by defense point if defense code nonzero.

   * owl_threaten_attack


           Function:  Try to attack a dragon in 2 moves.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   attack code followed by the two attack points if
                      attack code nonzero.

   * owl_threaten_defense


           Function:  Try to defend a dragon with 2 moves.
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   defense code followed by the 2 defense points if
                      defense code nonzero.

   * owl_does_attack


           Function:  Examine whether a specific move attacks a dragon.
           Arguments: vertex (move), vertex (dragon)
           Fails:     invalid vertex, empty vertex
           Returns:   attack code

   * owl_does_defend


           Function:  Examine whether a specific move defends a dragon.
           Arguments: vertex (move), vertex (dragon)
           Fails:     invalid vertex, empty vertex
           Returns:   defense code

   * owl_connection_defends


           Function:  Examine whether a connection defends involved dragons.
           Arguments: vertex (move), vertex (dragon1), vertex (dragon2)
           Fails:     invalid vertex, empty vertex
           Returns:   defense code

   * defend_both


           Function:  Try to defend both of two strings
           Arguments: two vertices
           Fails:     invalid vertex, empty vertex
           Returns:   defend code for the strings.  Guarantees there
                      exists a move which will defend both of the two
                      with defend_code, but does not return the move.

   * owl_substantial


           Function:  Determine whether capturing a string gives a living dragon
           Arguments: vertex
           Fails:     invalid vertex, empty vertex
           Returns:   1 if dragon can live, 0 otherwise

   * analyze_semeai


           Function:  Analyze a semeai
           Arguments: dragona, dragonb
           Fails:     invalid vertices, empty vertices
           Returns:   semeai defense result, semeai attack result, semeai move

   * analyze_semeai_after_move


           Function:  Analyze a semeai after a move have been made.
           Arguments: color, vertex, dragona, dragonb
           Fails:     invalid vertices
           Returns:   semeai defense result, semeai attack result, semeai move

   * tactical_analyze_semeai


           Function:  Analyze a semeai, not using owl
           Arguments: dragona, dragonb
           Fails:     invalid vertices, empty vertices
           Returns:   status of dragona, dragonb assuming dragona moves first

   * connect


           Function:  Try to connect two strings.
           Arguments: vertex, vertex
           Fails:     invalid vertex, empty vertex, vertices of different colors
           Returns:   connect result followed by connect point if successful.

   * disconnect


           Function:  Try to disconnect two strings.
           Arguments: vertex, vertex
           Fails:     invalid vertex, empty vertex, vertices of different colors
           Returns:   disconnect result followed by disconnect point if successful.

   * break_in


           Function:  Try to break from string into area.
           Arguments: vertex, vertices
           Fails:     invalid vertex, empty vertex.
           Returns:   result followed by break in point if successful.

   * block_off


           Function:  Try to block string from area.
           Arguments: vertex, vertices
           Fails:     invalid vertex, empty vertex.
           Returns:   result followed by block point if successful.

   * eval_eye


           Function:  Evaluate an eye space
           Arguments: vertex
           Fails:     invalid vertex
           Returns:   Minimum and maximum number of eyes. If these differ an
                      attack and a defense point are additionally returned.
                      If the vertex is not an eye space or not of unique color,
                      a single -1 is returned.

   * dragon_status


           Function:  Determine status of a dragon.
           Arguments: optional vertex
           Fails:     invalid vertex, empty vertex
           Returns:   status ("alive", "critical", "dead", or "unknown"),
                      attack point, defense point. Points of attack and
                      defense are only given if the status is critical.
                      If no vertex is given, the status is listed for all
                      dragons, one per row in the format "A4: alive".

           FIXME: Should be able to distinguish between life in seki
                  and independent life. Should also be able to identify ko.

   * same_dragon


           Function:  Determine whether two stones belong to the same dragon.
           Arguments: vertex, vertex
           Fails:     invalid vertex, empty vertex
           Returns:   1 if the vertices belong to the same dragon, 0 otherwise

   * unconditional_status


           Function:  Determine the unconditional status of a vertex.
           Arguments: vertex
           Fails:     invalid vertex
           Returns:   unconditional status ("undecided", "alive", "dead",
                      "white_territory", "black_territory"). Occupied vertices can
                      be undecided, alive, or dead. Empty vertices can be
                      undecided, white territory, or black territory.

   * combination_attack


           Function:  Find a move by color capturing something through a
                      combination attack.
           Arguments: color
           Fails:     invalid color
           Returns:   Recommended move, PASS if no move found

   * combination_defend


           Function:  If color can capture something through a
                      combination attack, list moves by the opponent of color
                      to defend against this attack.
           Arguments: color
           Fails:     invalid color
           Returns:   Recommended moves, PASS if no combination attack found.

   * aa_confirm_safety


           Function:  Run atari_atari_confirm_safety().
           Arguments: move, optional int
           Fails:     invalid move
           Returns:   success code, if failure also defending move

   * genmove_black


           Function:  Generate and play the supposedly best black move.
           Arguments: none
           Fails:     never
           Returns:   a move coordinate or "PASS"

           Status:    Obsolete GTP version 1 command.

   * genmove_white


           Function:  Generate and play the supposedly best white move.
           Arguments: none
           Fails:     never
           Returns:   a move coordinate or "PASS"

           Status:    Obsolete GTP version 1 command.

   * genmove


           Function:  Generate and play the supposedly best move for either color.
           Arguments: color to move
           Fails:     invalid color
           Returns:   a move coordinate or "PASS" (or "resign" if resignation_allowed)

           Status:    GTP version 2 standard command.

   * reg_genmove


           Function:  Generate the supposedly best move for either color.
           Arguments: color to move
           Fails:     invalid color
           Returns:   a move coordinate (or "PASS")

           Status:    GTP version 2 standard command.

   * gg_genmove


           Function:  Generate the supposedly best move for either color.
           Arguments: color to move, optionally a random seed
           Fails:     invalid color
           Returns:   a move coordinate (or "PASS")

           This differs from reg_genmove in the optional random seed.

   * restricted_genmove


           Function:  Generate the supposedly best move for either color from a
                      choice of allowed vertices.
           Arguments: color to move, allowed vertices
           Fails:     invalid color, invalid vertex, no vertex listed
           Returns:   a move coordinate (or "PASS")

   * kgs-genmove_cleanup


           Function:  Generate and play the supposedly best move for either color,
                      not passing until all dead opponent stones have been removed.
           Arguments: color to move
           Fails:     invalid color
           Returns:   a move coordinate (or "PASS")

           Status:    KGS specific command.

           A similar command, but possibly somewhat different, will likely be added
           to GTP version 3 at a later time.

   * level


           Function:  Set the playing level.
           Arguments: int
           Fails:     incorrect argument
           Returns:   nothing

   * undo


           Function:  Undo one move
           Arguments: none
           Fails:     If move history is too short.
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * gg-undo


           Function:  Undo a number of moves
           Arguments: optional int
           Fails:     If move history is too short.
           Returns:   nothing

   * time_settings


           Function:  Set time allowance
           Arguments: int main_time, int byo_yomi_time, int byo_yomi_stones
           Fails:     syntax error
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * time_left


           Function:  Report remaining time
           Arguments: color color, int time, int stones
           Fails:     syntax error
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * final_score


           Function:  Compute the score of a finished game.
           Arguments: Optional random seed
           Fails:     never
           Returns:   Score in SGF format (RE property).

           Status:    GTP version 2 standard command.

   * final_status


           Function:  Report the final status of a vertex in a finished game.
           Arguments: Vertex, optional random seed
           Fails:     invalid vertex
           Returns:   Status in the form of one of the strings "alive", "dead",
                      "seki", "white_territory", "black_territory", or "dame".

   * final_status_list


           Function:  Report vertices with a specific final status in a finished game.
           Arguments: Status in the form of one of the strings "alive", "dead",
                      "seki", "white_territory", "black_territory", or "dame".
                      An optional random seed can be added.
           Fails:     missing or invalid status string
           Returns:   Vertices having the specified status. These are split with
                      one string on each line if the vertices are nonempty (i.e.
                      for "alive", "dead", and "seki").

           Status:    GTP version 2 standard command.
                      However, "dame", "white_territory", and "black_territory"
                      are private extensions.

   * estimate_score


           Function:  Estimate the score
           Arguments: None
           Fails:     never
           Returns:   upper and lower bounds for the score

   * experimental_score


           Function:  Estimate the score, taking into account which player moves next
           Arguments: Color to play
           Fails:     Invalid color
           Returns:   Score.

           This function generates a move for color, then adds the
           value of the move generated to the value of the position.
           Critical dragons are awarded to the opponent since the
           value of rescuing a critical dragon is taken into account
           in the value of the move generated.

   * reset_life_node_counter


           Function:  Reset the count of life nodes.
           Arguments: none
           Fails:     never
           Returns:   nothing

           Note: This function is obsolete and only remains for backwards
           compatibility.

   * get_life_node_counter


           Function:  Retrieve the count of life nodes.
           Arguments: none
           Fails:     never
           Returns:   number of life nodes

           Note: This function is obsolete and only remains for backwards
           compatibility.

   * reset_owl_node_counter


           Function:  Reset the count of owl nodes.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * get_owl_node_counter


           Function:  Retrieve the count of owl nodes.
           Arguments: none
           Fails:     never
           Returns:   number of owl nodes

   * reset_reading_node_counter


           Function:  Reset the count of reading nodes.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * get_reading_node_counter


           Function:  Retrieve the count of reading nodes.
           Arguments: none
           Fails:     never
           Returns:   number of reading nodes

   * reset_trymove_counter


           Function:  Reset the count of trymoves/trykos.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * get_trymove_counter


           Function:  Retrieve the count of trymoves/trykos.
           Arguments: none
           Fails:     never
           Returns:   number of trymoves/trykos

   * reset_connection_node_counter


           Function:  Reset the count of connection nodes.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * get_connection_node_counter


           Function:  Retrieve the count of connection nodes.
           Arguments: none
           Fails:     never
           Returns:   number of connection nodes

   * test_eyeshape


           Function:  Test an eyeshape for inconsistent evaluations
           Arguments: Eyeshape vertices
           Fails:     Bad vertices
           Returns:   Failure reports on stderr.

   * analyze_eyegraph


           Function:  Compute an eyevalue and vital points for an eye graph
           Arguments: Eyeshape encoded in string
           Fails:     Bad eyeshape, analysis failed
           Returns:   Eyevalue, vital points

   * cputime


           Function:  Returns elapsed CPU time in seconds.
           Arguments: none
           Fails:     never
           Returns:   Total elapsed (user + system) CPU time in seconds.

   * showboard


           Function:  Write the position to stdout.
           Arguments: none
           Fails:     never
           Returns:   nothing

           Status:    GTP version 2 standard command.

   * dump_stack


           Function:  Dump stack to stderr.
           Arguments: none
           Fails:     never
           Returns:   nothing

   * initial_influence


           Function:  Return information about the initial influence function.
           Arguments: color to move, what information
           Fails:     never
           Returns:   Influence data formatted like:

             0.51   1.34   3.20   6.60   9.09   8.06   1.96   0.00   0.00
             0.45   1.65   4.92  12.19  17.47  15.92   4.03   0.00   0.00
                             .
                             .
                             .
             0.00   0.00   0.00   0.00   0.00 100.00  75.53  41.47  23.41

           The available choices of information are:

           white_influence (float)
           black_influence (float)
           white_strength (float)
           black_strength (float)
           white_attenuation (float)
           black_attenuation (float)
           white_permeability (float)
           black_permeability (float)
           territory_value (float)
           influence_regions (int)
           non_territory (int)

           The encoding of influence_regions is as follows:
            4 white stone
            3 white territory
            2 white moyo
            1 white area
            0 neutral
           -1 black area
           -2 black moyo
           -3 black territory
           -4 black stone

   * move_influence


           Function:  Return information about the influence function after a move.
           Arguments: move, what information
           Fails:     never
           Returns:   Influence data formatted like for initial_influence.

   * move_probabilities


           Function:  List probabilities of each move being played (when non-zero).
                      If no previous genmove command has been issued, the result
                      of this command will be meaningless.
           Arguments: none
           Fails:     never
           Returns:   Move, probabilty pairs, one per row.

   * move_uncertainty


           Function:  Return the number of bits of uncertainty in the move.
                      If no previous genmove command has been issued, the result
                      of this command will be meaningless.
           Arguments: none
           Fails:     never
           Returns:   bits of uncertainty

   * followup_influence


           Function:  Return information about the followup influence after a move.
           Arguments: move, what information
           Fails:     never
           Returns:   Influence data formatted like for initial_influence.

   * worm_data


           Function:  Return the information in the worm data structure.
           Arguments: optional vertex
           Fails:     never
           Returns:   Worm data formatted like:

           A19:
           color           black
           size            10
           effective_size  17.83
           origin          A19
           liberties       8
           liberties2      15
           liberties3      10
           liberties4      8
           attack          PASS
           attack_code     0
           lunch           B19
           defend          PASS
           defend_code     0
           cutstone        2
           cutstone2       0
           genus           0
           inessential     0
           B19:
           color           white
           .
           .
           .
           inessential     0
           C19:
           ...

           If an intersection is specified, only data for this one will be returned.

   * worm_stones


           Function:  List the stones of a worm
           Arguments: the location, "BLACK" or "WHITE"
           Fails:     if called on an empty or off-board location
           Returns:   list of stones

   * worm_cutstone


           Function:  Return the cutstone field in the worm data structure.
           Arguments: non-empty vertex
           Fails:     never
           Returns:   cutstone

   * dragon_data


           Function:  Return the information in the dragon data structure.
           Arguments: optional intersection
           Fails:     never
           Returns:   Dragon data formatted in the corresponding way to worm_data.

   * dragon_stones


           Function:  List the stones of a dragon
           Arguments: the location
           Fails:     if called on an empty or off-board location
           Returns:   list of stones

   * eye_data


           Function:  Return the information in the eye data structure.
           Arguments: color, vertex
           Fails:     never
           Returns:   eye data fields and values, one pair per row

   * half_eye_data


           Function:  Return the information in the half eye data structure.
           Arguments: vertex
           Fails:     never
           Returns:   half eye data fields and values, one pair per row

   * start_sgftrace


           Function:  Start storing moves executed during reading in an sgf
                      tree in memory.
           Arguments: none
           Fails:     never
           Returns:   nothing

           Warning: You had better know what you're doing if you try to use this
                    command.

   * finish_sgftrace


           Function:  Finish storing moves in an sgf tree and write it to file.
           Arguments: filename
           Fails:     never
           Returns:   nothing

           Warning: You had better know what you're doing if you try to use this
                    command.

   * printsgf


           Function:  Dump the current position as a static sgf file
           Arguments: filename
           Fails:     missing filename
           Returns:   nothing

   * tune_move_ordering


           Function:  Tune the parameters for the move ordering in the tactical
                      reading.
           Arguments: MOVE_ORDERING_PARAMETERS integers
           Fails:     incorrect arguments
           Returns:   nothing

   * echo


           Function:  Echo the parameter
           Arguments: string
           Fails:     never
           Returns:   nothing

   * echo_err


           Function:  Echo the parameter to stdout AND stderr
           Arguments: string
           Fails:     never
           Returns:   nothing

   * help


           Function:  List all known commands
           Arguments: none
           Fails:     never
           Returns:   list of known commands, one per line

           Status:    GTP version 2 standard command.

   * known_command


           Function:  Tell whether a command is known.
           Arguments: command name
           Fails:     never
           Returns:   "true" if command exists, "false" if not

           Status:    GTP version 2 standard command.

   * report_uncertainty


           Function:  Turn uncertainty reports from owl_attack
                      and owl_defend on or off.
           Arguments: "on" or "off"
           Fails:     invalid argument
           Returns:   nothing

   * get_random_seed


           Function:  Get the random seed
           Arguments: none
           Fails:     never
           Returns:   random seed

   * set_random_seed


           Function:  Set the random seed
           Arguments: integer
           Fails:     invalid data
           Returns:   nothing

   * is_surrounded


           Function:  Determine if a dragon is surrounded
           Arguments: vertex (dragon)
           Fails:     invalid vertex, empty vertex
           Returns:   1 if surrounded, 2 if weakly surrounded, 0 if not

   * does_surround


           Function:  Determine if a move surrounds a dragon
           Arguments: vertex (move), vertex (dragon)
           Fails:     invalid vertex, empty (dragon, nonempty (move)
           Returns:   1 if (move) surrounds (dragon)

   * surround_map


           Function:  Report the surround map for dragon at a vertex
           Arguments: vertex (dragon), vertex (mapped location)
           Fails:     invalid vertex, empty dragon
           Returns:   value of surround map at (mapped location), or -1 if
                      dragon not surrounded.

   * set_search_diamond


           Function:  limit search, and establish a search diamond
           Arguments: pos
           Fails:     invalid value
           Returns:   nothing

   * reset_search_mask


           Function:  unmark the entire board for limited search
           Arguments: none
           Fails:     never
           Returns:   nothing

   * limit_search


           Function:  sets the global variable limit_search
           Arguments: value
           Fails:     invalid arguments
           Returns:   nothing

   * set_search_limit


           Function:  mark a vertex for limited search
           Arguments: position
           Fails:     invalid arguments
           Returns:   nothing

   * draw_search_area


           Function:  Draw search area. Writes to stderr.
           Arguments: none
           Fails:     never
           Returns:   nothing



File: gnugo.info,  Node: Regression,  Next: Copying,  Prev: GTP,  Up: Top

20 Regression testing
*********************

The standard purpose of regression testing is to avoid getting the same
bug twice. When a bug is found, the programmer fixes the bug and adds a
test to the test suite. The test should fail before the fix and pass
after the fix. When a new version is about to be released, all the tests
in the regression test suite are run and if an old bug reappears, this
will be seen quickly since the appropriate test will fail.

   The regression testing in GNU Go is slightly different. A typical
test case involves specifying a position and asking the engine what
move it would make. This is compared to one or more correct moves to
decide whether the test case passes or fails. It is also stored whether
a test case is expected to pass or fail, and deviations in this status
signify whether a change has solved some problem and/or broken something
else. Thus the regression tests both include positions highlighting some
mistake being done by the engine, which are waiting to be fixed, and
positions where the engine does the right thing, where we want to detect
if a change breaks something.

* Menu:

* Regression Testing::          Regression Testing in GNU Go
* Test Suites::                 Test Suites
* Running the Regressions::     Running the Regression Tests
* Running regress.pike::        Running regress.pike
* Viewing with Emacs::          Viewing tests with Emacs
* HTML Views::                  HTML Views


File: gnugo.info,  Node: Regression Testing,  Next: Test Suites,  Up: Regression

20.1 Regression testing in GNU Go
=================================

Regression testing is performed by the files in the `regression/'
directory. The tests are specified as GTP commands in files with the
suffix `.tst', with corresponding correct results and expected
pass/fail status encoded in GTP comments following the test. To run a
test suite the shell scripts `test.sh', `eval.sh', and `regress.sh' can
be used. There are also Makefile targets to do this. If you `make
all_batches' most of the tests are run. The Pike script `regress.pike'
can also be used to run all tests or a subset of the tests.

   Game records used by the regression tests are stored in the
directory `regression/games/' and its subdirectories.


File: gnugo.info,  Node: Test Suites,  Next: Running the Regressions,  Prev: Regression Testing,  Up: Regression

20.2 Test suites
================

The regression tests are grouped into suites and stored in files as GTP
commands. A part of a test suite can look as follows:
     # Connecting with ko at B14 looks best. Cutting at D17 might be
     # considered. B17 (game move) is inferior.
     loadsgf games/strategy25.sgf 61
     90 gg_genmove black
     #? [B14|D17]

     # The game move at P13 is a suicidal blunder.
     loadsgf games/strategy25.sgf 249
     95 gg_genmove black
     #? [!P13]

     loadsgf games/strategy26.sgf 257
     100 gg_genmove black
     #? [M16]*

   Lines starting with a hash sign, or in general anything following a
hash sign, are interpreted as comments by the GTP mode and thus ignored
by the engine. GTP commands are executed in the order they appear, but
only those on numbered lines are used for testing. The comment lines
starting with `#?' are magical to the regression testing scripts and
indicate correct results and expected pass/fail status. The string
within brackets is matched as a regular expression against the response
from the previous numbered GTP command. A particular useful feature of
regular expressions is that by using `|' it is possible to specify
alternatives. Thus `B14|D17' above means that if either `B14' or `D17'
is the move generated in test case 90, it passes. There is one
important special case to be aware of. If the correct result string
starts with an exclamation mark, this is excluded from the regular
expression but afterwards the result of the matching is negated. Thus
`!P13' in test case 95 means that any move except `P13' is accepted as
a correct result.

   In test case 100, the brackets on the `#?' line is followed by an
asterisk. This means that the test is expected to fail. If there is no
asterisk, the test is expected to pass. The brackets may also be
followed by a `&', meaning that the result is ignored. This is
primarily used to report statistics, e.g. how many tactical reading
nodes were spent while running the test suite.


File: gnugo.info,  Node: Running the Regressions,  Next: Running regress.pike,  Prev: Test Suites,  Up: Regression

20.3 Running the Regression Tests
=================================

`./test.sh blunder.tst' runs the tests in `blunder.tst' and prints the
results of the commands on numbered lines, which may look like:

     1 E5
     2 F9
     3 O18
     4 B7
     5 A4
     6 E4
     7 E3
     8 A3
     9 D9
     10 J9
     11 B3
     12 C6
     13 C6

   This is usually not very informative, however. More interesting is
`./eval.sh blunder.tst' which also compares the results above against
the correct ones in the test file and prints a report for each test on
the form:

     1 failed: Correct '!E5', got 'E5'
     2 failed: Correct 'C9|H9', got 'F9'
     3 PASSED
     4 failed: Correct 'B5|C5|C4|D4|E4|E3|F3', got 'B7'
     5 PASSED
     6 failed: Correct 'D4', got 'E4'
     7 PASSED
     8 failed: Correct 'B4', got 'A3'
     9 failed: Correct 'G8|G9|H8', got 'D9'
     10 failed: Correct 'G9|F9|C7', got 'J9'
     11 failed: Correct 'D4|E4|E5|F4|C6', got 'B3'
     12 failed: Correct 'D4', got 'C6'
     13 failed: Correct 'D4|E4|E5|F4', got 'C6'

   The result of a test can be one of four different cases:

   * `passed': An expected pass

     This is the ideal result.

   * `PASSED': An unexpected pass

     This is a result that we are hoping for when we fix a bug. An old
     test case that used to fail is now passing.

   * `failed': An expected failure

     The test failed but this was also what we expected, unless we were
     trying to fix the particular mistake highlighted by the test case.
     These tests show weaknesses of the GNU Go engine and are good
     places to search if you want to detect an area which needs
     improvement.

   * `FAILED': An unexpected failure

     This should nominally only happen if something is broken by a
     change. However, sometimes GNU Go passes a test, but for the wrong
     reason or for a combination of wrong reasons.  When one of these
     reasons is fixed, the other one may shine through so that the test
     suddenly fails. When a test case unexpectedly fails, it is
     necessary to make a closer examination in order to determine
     whether a change has broken something.


   If you want a less verbose report, `./regress.sh . blunder.tst' does
the same thing as the previous command, but only reports unexpected
results. The example above is compressed to

     3 unexpected PASS!
     5 unexpected PASS!
     7 unexpected PASS!

   For convenience the tests are also available as makefile targets. For
example, `make blunder' runs the tests in the blunder test suite by
executing `eval.sh blunder.tst'. `make all_batches' runs all test
suites in a sequence using the `regress.sh' script.


File: gnugo.info,  Node: Running regress.pike,  Next: Viewing with Emacs,  Prev: Running the Regressions,  Up: Regression

20.4 Running regress.pike
=========================

A more powerful way to run regressions is with the script
`regress.pike'. This requires that you have Pike
(`http://pike.ida.liu.se') installed.

   Executing `./regress.pike' without arguments will run all testsuites
that `make all_batches' would run. The difference is that unexpected
results are reported immediately when they have been found (instead of
after the whole file has been run) and that statistics of time
consumption and node usage is presented for each test file and in total.

   To run a single test suite do e.g. `./regress.pike nicklas3.tst' or
`./regress.pike nicklas3'. The result may look like:
     nicklas3                                 2.96    614772    3322      469
     Total nodes: 614772 3322 469
     Total time: 2.96 (3.22)
     Total uncertainty: 0.00
   The numbers here mean that the test suite took 2.96 seconds of
processor time and 3.22 seconds of real time. The consumption of
reading nodes was 614772 for tactical reading, 3322 for owl reading,
and 469 for connection reading. The last line relates to the
variability of the generated moves in the test suite, and 0 means that
none was decided by the randomness contribution to the move valuation.
Multiple testsuites can be run by e.g. `./regress.pike owl ld_owl owl1'.

   It is also possible to run a single testcase, e.g. `./regress.pike
strategy:6', a number of testcases, e.g. `./regress.pike
strategy:6,23,45', a range of testcases, e.g. `./regress.pike
strategy:13-15' or more complex combinations e.g. `./regress.pike
strategy:6,13-15,23,45 nicklas3:602,1403'.

   There are also command line options to choose what engine to run,
what options to send to the engine, to turn on verbose output, and to
use a file to specify which testcases to run. Run `./regress.pike
--help' for a complete and up to date list of options.


File: gnugo.info,  Node: Viewing with Emacs,  Next: HTML Views,  Prev: Running regress.pike,  Up: Regression

20.5 Viewing tests with Emacs
=============================

To get a quick regression view, you may use the graphical display mode
available with Emacs (*note Emacs::). You will want the cursor in the
regression buffer when you enter `M-x gnugo', so that GNU Go opens in
the correct directory. A good way to be in the right directory is to
open the window of the test you want to investigate. Then you can cut
and past GTP commands directly from the test to the minibuffer, using
the `:' command from Emacs. Although Emacs mode does not have a
coordinate grid, you may get an ascii board with the coordinate grid
using `: showboard' command.


File: gnugo.info,  Node: HTML Views,  Prev: Viewing with Emacs,  Up: Regression

20.6 HTML Regression Views
==========================

Extremely useful HTML Views of the regression tests may be produced
using two perl scripts `regression/regress.pl' and
`regression/regress.plx'.

  1. The driver program (regress.pl) which:
        * Runs the regression tests, invoking GNU Go.

        * Captures the trace output, board position, and pass/fail
          status, sgf output, and dragon status information.

  2. The interface to view the captured output (regress.plx) which:
        * Never invokes GNU Go.

        * Displays the captured output in helpful formats (i.e. HTML).

20.6.1 Setting up the HTML regression Views
-------------------------------------------

This documentation assumes an apache configured as per Debian's Apache
1.3 distribution, but it should be fairly close to the config for other
distributions.

   First, you will need to configure Apache to run CGI scripts in the
directory you wish to serve the html views from.  To do this, add the
following to `/etc/apache/httpd.conf' (or to a user-specific conf file
if applicable):

     <Directory /path/to/script/>
         Options +ExecCGI
     </Directory>

   This allows CGI scripts to be executed in the directory used by
regress.plx.  Next, you need to tell Apache that `.plx' is a CGI script
ending.  Your `httpd.conf' file should contain a section `<IfModule
mod_mime.c>'.  Within that section, there may or may not be a line:

   `AddHandler cgi-script ....'

   If there isn't already, add it; add `.plx' to the list of extensions.

   You will also need to make sure you have the necessary modules
loaded to run CGI scripts; mod_cgi and mod_mime should be sufficient.
Your `httpd.conf' should have the relevant `LoadModule' lines;
uncomment them if neccessary.

   Next, you need to put a copy of `regress.plx' in the directory that
you plan to serve the html views from.

   You will also need to install the Perl module GD, available from
CPAN or via `apt-get install libgd-perl' on Debian.

   Finally, run `regression/regress.pl' to create the xml data used to
generate the html views; then, copy the `html/' directory to the same
directory as `regress.plx' resides in.

   At this point, you should have a working copy of the html regression
views.


File: gnugo.info,  Node: Copying,  Next: Concept Index,  Prev: Regression,  Up: Top

Appendix A Copying
******************

The program GNU Go is distributed under the terms of the GNU General
Public License (GPL). Its documentation is distributed under the terms
of the GNU Free Documentation License (GFDL).

* Menu:

* GPL::            The GNU General Public License
* GFDL::           The GNU Free Documentation License
* GTP License::    The Go Text Protocol License


File: gnugo.info,  Node: GPL,  Next: GFDL,  Prev: Copying,  Up: Copying

A.1 GNU GENERAL PUBLIC LICENSE
==============================

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     as published by the Free Software Foundation; either version 2
     of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with this program; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.  This is free software, and you are welcome
     to redistribute it under certain conditions; type `show c'
     for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright
     interest in the program `Gnomovision'
     (which makes passes at compilers) written
     by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: gnugo.info,  Node: GFDL,  Next: GTP License,  Prev: GPL,  Up: Copying

A.2 GNU FREE DOCUMENTATION LICENSE
==================================

                        Version 1.1, March 2000

     Copyright (C) 2000  Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.


  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     written document "free" in the sense of freedom: to assure everyone
     the effective freedom to copy and redistribute it, with or without
     modifying it, either commercially or noncommercially.  Secondarily,
     this License preserves for the author and publisher a way to get
     credit for their work, while not being considered responsible for
     modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.


  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work that contains a
     notice placed by the copyright holder saying it can be distributed
     under the terms of this License.  The "Document", below, refers to
     any such manual or work.  Any member of the public is a licensee,
     and is addressed as "you".

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter
     section of the Document that deals exclusively with the
     relationship of the publishers or authors of the Document to the
     Document's overall subject (or to related matters) and contains
     nothing that could fall directly within that overall subject.
     (For example, if the Document is in part a textbook of
     mathematics, a Secondary Section may not explain any mathematics.)
     The relationship could be a matter of historical connection with
     the subject or with related matters, or of legal, commercial,
     philosophical, ethical or political position regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, whose contents can be viewed and edited directly
     and straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup has been designed
     to thwart or discourage subsequent modification by readers is not
     Transparent.  A copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML designed for human modification.
     Opaque formats include PostScript, PDF, proprietary formats that
     can be read and edited only by proprietary word processors, SGML
     or XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies of the Document numbering more than
     100, and the Document's license notice requires Cover Texts, you
     must enclose the copies in covers that carry, clearly and legibly,
     all these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a publicly-accessible
     computer-network location containing a complete Transparent copy
     of the Document, free of added material, which the general
     network-using public has access to download anonymously at no
     charge using public-standard network protocols.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.
       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has less than five).
       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.
       D. Preserve all the copyright notices of the Document.
       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.
       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.
       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.
       H. Include an unaltered copy of this License.
       I. Preserve the section entitled "History", and its title, and
          add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.
       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.
       K. In any section entitled "Acknowledgements" or "Dedications",
          preserve the section's title, and preserve in the section all
          the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.
       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.
       M. Delete any section entitled "Endorsements".  Such a section
          may not be included in the Modified Version.
       N. Do not retitle any existing section as "Endorsements" or to
          conflict in title with any Invariant Section.


     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties-for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition
     of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections entitled
     "History" in the various original documents, forming one section
     entitled "History"; likewise combine any sections entitled
     "Acknowledgements", and any sections entitled "Dedications".  You
     must delete all sections entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, does not as a whole count as a
     Modified Version of the Document, provided no compilation
     copyright is claimed for the compilation.  Such a compilation is
     called an "aggregate", and this License does not apply to the
     other self-contained works thus compiled with the Document, on
     account of their being thus compiled, if they are not themselves
     derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one
     quarter of the entire aggregate, the Document's Cover Texts may be
     placed on covers that surround only the Document within the
     aggregate.  Otherwise they must appear on covers around the whole
     aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License provided that you also include the
     original English version of this License.  In case of a
     disagreement between the translation and the original English
     version of this License, the original English version will prevail.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     http://www.gnu.org/copyleft/.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:


       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.1
       or any later version published by the Free Software Foundation;
       with the Invariant Sections being LIST THEIR TITLES, with the
       Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
       A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have no Invariant Sections, write "with no Invariant Sections"
instead of saying which ones are invariant.  If you have no Front-Cover
Texts, write "no Front-Cover Texts" instead of "Front-Cover Texts being
LIST"; likewise for Back-Cover Texts.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License, to
permit their use in free software.


File: gnugo.info,  Node: GTP License,  Prev: GFDL,  Up: Copying

A.3 The Go Text Protocol License
================================

In order to facilitate the use of the Go Text Protocol, the two files
`gtp.c' and `gtp.h' are licensed under the following terms.

   Copyright 2001 by the Free Software Foundation.

   Permission is hereby granted, free of charge, to any person
obtaining a copy of this file `gtp.x', to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, and/or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so,
provided that the above copyright notice(s) and this permission notice
appear in all copies of the Software and that both the above copyright
notice(s) and this permission notice appear in supporting documentation.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

   Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.


File: gnugo.info,  Node: Concept Index,  Next: Functions Index,  Prev: Copying,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* aa_confirm_safety:                     GTP command reference.
                                                             (line  582)
* accurate_approxlib:                    GTP command reference.
                                                             (line  250)
* accuratelib:                           GTP command reference.
                                                             (line  241)
* adjacent dragons:                      Dragons.            (line  145)
* all_legal:                             GTP command reference.
                                                             (line  270)
* amalgamation of worms into dragons:    Amalgamation.       (line    6)
* analyze_eyegraph:                      GTP command reference.
                                                             (line  860)
* analyze_semeai:                        GTP command reference.
                                                             (line  462)
* analyze_semeai_after_move:             GTP command reference.
                                                             (line  470)
* API:                                   API.                (line   26)
* area:                                  Territory and Moyo. (line    6)
* ascii description of shapes:           Patterns Overview.  (line   27)
* ascii interface:                       Ascii.              (line    6)
* ascii mode:                            Invoking GNU Go.    (line  249)
* attack:                                GTP command reference.
                                                             (line  336)
* attack shapes database:                Patterns Overview.  (line    6)
* attack_either:                         GTP command reference.
                                                             (line  344)
* autohelper actions:                    Autohelper Actions. (line    6)
* Autohelpers:                           Autohelpers and Constraints.
                                                             (line    6)
* automaton:                             DFA.                (line   29)
* black:                                 GTP command reference.
                                                             (line  130)
* block_off:                             GTP command reference.
                                                             (line  510)
* board_state:                           The Board State.    (line    6)
* boardsize:                             GTP command reference.
                                                             (line   68)
* break_in:                              GTP command reference.
                                                             (line  502)
* cache:                                 Invoking GNU Go.    (line   84)
* cache-size:                            Invoking GNU Go.    (line   84)
* captures:                              GTP command reference.
                                                             (line  278)
* CGoban:                                CGoban.             (line    6)
* clear_board:                           GTP command reference.
                                                             (line   86)
* clear_cache:                           GTP command reference.
                                                             (line  328)
* color:                                 GTP command reference.
                                                             (line  209)
* color (dragon):                        Dragons.            (line   98)
* colored display <1>:                   Dragons in Color.   (line    6)
* colored display:                       Colored Display.    (line    6)
* combination_attack:                    GTP command reference.
                                                             (line  563)
* combination_defend:                    GTP command reference.
                                                             (line  572)
* command line options:                  Invoking GNU Go.    (line    6)
* connect:                               GTP command reference.
                                                             (line  486)
* connection shapes database <1>:        Connections Database.
                                                             (line    6)
* connection shapes database:            Patterns Overview.  (line    6)
* connections:                           Connection.         (line    6)
* connections database:                  Connections Database.
                                                             (line    6)
* corner matcher:                        Corner Matcher.     (line    6)
* countlib:                              GTP command reference.
                                                             (line  225)
* cputime:                               GTP command reference.
                                                             (line  868)
* cutting stone:                         Worms.              (line  124)
* cutting stone, potential:              Worms.              (line  133)
* data structures:                       Basic Data Structures.
                                                             (line    6)
* debugboard:                            Debugboard.         (line    6)
* debugging options:                     Invoking GNU Go.    (line  313)
* Debugging the reading code:            Debugging.          (line    6)
* decide-dragon:                         Decide dragon.      (line    6)
* decide-string:                         Decide string.      (line    6)
* decrease_depths:                       GTP command reference.
                                                             (line  378)
* defence shapes database:               Patterns Overview.  (line    6)
* defend:                                GTP command reference.
                                                             (line  354)
* defend_both:                           GTP command reference.
                                                             (line  444)
* depth:                                 Invoking GNU Go.    (line  155)
* Depth of reading:                      Tactical Reading.   (line    6)
* description of shapes:                 Patterns Overview.  (line   27)
* dfa:                                   DFA.                (line   29)
* dfa.c:                                 DFA.                (line   29)
* dfa.h:                                 DFA.                (line   29)
* disconnect:                            GTP command reference.
                                                             (line  494)
* distance from liberty to dragon:       Worms.              (line  109)
* does_surround:                         GTP command reference.
                                                             (line 1164)
* dragon:                                Worms and Dragons.  (line   27)
* dragon escape_route:                   Dragons.            (line  207)
* dragon genus:                          Dragons.            (line  213)
* dragon lunch:                          Dragons.            (line  230)
* dragon number:                         Dragons.            (line  100)
* dragon origin:                         Dragons.            (line  104)
* dragon safety:                         Dragons.            (line  176)
* dragon size:                           Dragons.            (line  112)
* dragon status:                         Dragons.            (line  131)
* dragon weakness:                       Dragons.            (line  199)
* dragon_data:                           GTP command reference.
                                                             (line 1023)
* dragon_status:                         GTP command reference.
                                                             (line  529)
* dragon_stones:                         GTP command reference.
                                                             (line 1031)
* dragons:                               Dragons.            (line    6)
* draw_search_area:                      GTP command reference.
                                                             (line 1213)
* dump_stack:                            GTP command reference.
                                                             (line  886)
* echo:                                  GTP command reference.
                                                             (line 1095)
* echo_err:                              GTP command reference.
                                                             (line 1103)
* editing pattern database:              Editing Patterns.   (line    6)
* editing patterns:                      Editing Patterns.   (line    6)
* effective size:                        Dragons.            (line  116)
* effective size (worm):                 Worms.              (line   48)
* eliminate the randomness:              Tuning.             (line  155)
* emacs mode:                            Emacs.              (line    6)
* escape_route:                          Dragons.            (line  207)
* estimate_score:                        GTP command reference.
                                                             (line  744)
* eval_eye:                              GTP command reference.
                                                             (line  518)
* experimental_score:                    GTP command reference.
                                                             (line  752)
* eye shapes database:                   Patterns Overview.  (line    6)
* eye space display:                     Colored Display.    (line   48)
* eye_data:                              GTP command reference.
                                                             (line 1039)
* false eye:                             Half Eyes.          (line    6)
* fast pattern matching:                 DFA.                (line   29)
* final_score:                           GTP command reference.
                                                             (line  709)
* final_status:                          GTP command reference.
                                                             (line  719)
* final_status_list:                     GTP command reference.
                                                             (line  728)
* findlib:                               GTP command reference.
                                                             (line  233)
* finish_sgftrace:                       GTP command reference.
                                                             (line 1067)
* finite state automaton:                DFA.                (line   29)
* fixed_handicap:                        GTP command reference.
                                                             (line  160)
* FIXME:                                 Coding Styles.      (line   83)
* followup_influence:                    GTP command reference.
                                                             (line  962)
* format of the pattern database:        Patterns Overview.  (line   27)
* formatted printing:                    Print Utilities.    (line    6)
* GDB <1>:                               Debugging.          (line   30)
* GDB:                                   GTP and GDB techniques.
                                                             (line    6)
* generation of helper functions:        Autohelpers and Constraints.
                                                             (line    6)
* genmove:                               GTP command reference.
                                                             (line  610)
* genmove_black:                         GTP command reference.
                                                             (line  590)
* genmove_white:                         GTP command reference.
                                                             (line  600)
* genus:                                 Dragons.            (line  213)
* genus (worm):                          Worms.              (line  155)
* get_connection_node_counter:           GTP command reference.
                                                             (line  844)
* get_handicap:                          GTP command reference.
                                                             (line  190)
* get_komi:                              GTP command reference.
                                                             (line  122)
* get_life_node_counter:                 GTP command reference.
                                                             (line  777)
* get_owl_node_counter:                  GTP command reference.
                                                             (line  796)
* get_random_seed:                       GTP command reference.
                                                             (line 1140)
* get_reading_node_counter:              GTP command reference.
                                                             (line  812)
* get_trymove_counter:                   GTP command reference.
                                                             (line  828)
* gg-undo:                               GTP command reference.
                                                             (line  681)
* gg_genmove:                            GTP command reference.
                                                             (line  630)
* gGo:                                   Other Clients.      (line    6)
* glGo:                                  Other Clients.      (line    6)
* GMP:                                   GMP and GTP.        (line    6)
* gnugo's gdb commands:                  Debugging.          (line   82)
* go position:                           Hash Calculation.   (line   10)
* grid optimization:                     Details.            (line    6)
* GTP <1>:                               GTP and GDB techniques.
                                                             (line    6)
* GTP:                                   GMP and GTP.        (line    6)
* half eye:                              Half Eyes.          (line    6)
* half_eye_data:                         GTP command reference.
                                                             (line 1047)
* Hash node:                             Hash Organization.  (line    8)
* Hashing of positions:                  Hashing.            (line    6)
* help:                                  GTP command reference.
                                                             (line 1111)
* helper functions in pattern matching:  Helper Functions.   (line    6)
* how gnugo learn new joseki:            Joseki Compiler.    (line    6)
* How to debug the reading code:         Debugging.          (line    6)
* implementation of pattern matching <1>: Corner Matcher.    (line    6)
* implementation of pattern matching:    PM Implementation.  (line    6)
* increase_depths:                       GTP command reference.
                                                             (line  370)
* inessential string:                    Worms.              (line  165)
* initial_influence:                     GTP command reference.
                                                             (line  894)
* installation:                          GNU/Linux and Unix. (line    6)
* invincible worm:                       Worms.              (line  178)
* invoking GNU Go:                       Invoking GNU Go.    (line    6)
* is_legal:                              GTP command reference.
                                                             (line  262)
* is_surrounded:                         GTP command reference.
                                                             (line 1156)
* jago:                                  Other Clients.      (line    6)
* joseki <1>:                            Corner Matcher.     (line    6)
* joseki:                                Joseki Compiler.    (line    6)
* kgs-genmove_cleanup:                   GTP command reference.
                                                             (line  649)
* known_command:                         GTP command reference.
                                                             (line 1121)
* komi:                                  GTP command reference.
                                                             (line  112)
* ladder_attack:                         GTP command reference.
                                                             (line  362)
* last_move:                             GTP command reference.
                                                             (line  286)
* level <1>:                             GTP command reference.
                                                             (line  663)
* level:                                 Invoking GNU Go.    (line  139)
* level of play:                         Invoking GNU Go.    (line   25)
* liberties (worm):                      Worms.              (line   74)
* liberties, higher order (worm):        Worms.              (line   74)
* licence, documentation (GFDL):         GFDL.               (line    3)
* licence, program (GPL):                GPL.                (line    3)
* limit_search:                          GTP command reference.
                                                             (line 1197)
* list_stones:                           GTP command reference.
                                                             (line  217)
* loadsgf:                               GTP command reference.
                                                             (line  198)
* lunch:                                 Dragons.            (line  230)
* lunch (worm):                          Worms.              (line  114)
* matchpat.c:                            DFA.                (line   29)
* move generation:                       Move Generators.    (line    6)
* move generators:                       Move Generators.    (line    6)
* move reasons <1>:                      Move Reasons.       (line    6)
* move reasons:                          Move Generators.    (line    6)
* move_history:                          GTP command reference.
                                                             (line  294)
* move_influence:                        GTP command reference.
                                                             (line  934)
* move_probabilities:                    GTP command reference.
                                                             (line  942)
* move_uncertainty:                      GTP command reference.
                                                             (line  952)
* moyo:                                  Territory and Moyo. (line    6)
* moyo display:                          Colored Display.    (line   54)
* name:                                  GTP command reference.
                                                             (line   48)
* neighbor dragons:                      Dragons.            (line  145)
* orientation:                           GTP command reference.
                                                             (line   96)
* origin (worm):                         Worms.              (line   58)
* output file:                           Output File.        (line    6)
* owl_attack:                            GTP command reference.
                                                             (line  386)
* owl_attack_certain:                    Dragons.            (line  296)
* owl_attack_code:                       Dragons.            (line  291)
* owl_attack_point:                      Dragons.            (line  286)
* owl_connection_defends:                GTP command reference.
                                                             (line  436)
* owl_defend:                            GTP command reference.
                                                             (line  394)
* owl_defense_certain:                   Dragons.            (line  314)
* owl_defense_code:                      Dragons.            (line  309)
* owl_defense_point:                     Dragons.            (line  305)
* owl_does_attack:                       GTP command reference.
                                                             (line  420)
* owl_does_defend:                       GTP command reference.
                                                             (line  428)
* owl_second_attack_point:               Dragons.            (line  301)
* owl_second_defense_point:              Dragons.            (line  319)
* owl_substantial:                       GTP command reference.
                                                             (line  454)
* owl_threaten_attack:                   GTP command reference.
                                                             (line  402)
* owl_threaten_defense:                  GTP command reference.
                                                             (line  411)
* pattern attributes:                    Pattern Classification.
                                                             (line    6)
* pattern database <1>:                  DFA.                (line   29)
* pattern database:                      Patterns Overview.  (line    6)
* pattern matching <1>:                  DFA.                (line   29)
* pattern matching:                      Patterns Overview.  (line    6)
* pattern matching optimization:         Details.            (line    6)
* pattern overview:                      Patterns Overview.  (line    6)
* pattern.c:                             Patterns Overview.  (line    6)
* pattern.h:                             Patterns Overview.  (line    6)
* persistent cache:                      Persistent Cache.   (line    6)
* place_free_handicap:                   GTP command reference.
                                                             (line  170)
* play:                                  GTP command reference.
                                                             (line  150)
* playwhite:                             GTP command reference.
                                                             (line  140)
* popgo:                                 GTP command reference.
                                                             (line  320)
* position:                              Hash Calculation.   (line   10)
* position struct:                       Basic Data Structures.
                                                             (line    6)
* potential cutting stone:               Worms.              (line  133)
* printsgf:                              GTP command reference.
                                                             (line 1078)
* product:                               DFA.                (line   29)
* protocol_version:                      GTP command reference.
                                                             (line   38)
* qGo:                                   Other Clients.      (line    6)
* quarry:                                Other Clients.      (line    6)
* query_boardsize:                       GTP command reference.
                                                             (line   78)
* query_orientation:                     GTP command reference.
                                                             (line  104)
* quit:                                  GTP command reference.
                                                             (line   28)
* Read result:                           Hash Organization.  (line    8)
* Reading code:                          Tactical Reading.   (line    6)
* Reading code debugging tools:          Debugging.          (line    6)
* reading DEPTH:                         Tactical Reading.   (line    6)
* Reading optimisation:                  Hashing.            (line    6)
* Reading process:                       Tactical Reading.   (line    6)
* reading return codes:                  Reading Basics.     (line   51)
* reading shadow:                        Persistent Cache.   (line   50)
* reading.c <1>:                         Reading Basics.     (line  122)
* reading.c:                             Tactical Reading.   (line    6)
* reading.h:                             Tactical Reading.   (line    6)
* reg_genmove:                           GTP command reference.
                                                             (line  620)
* report_uncertainty:                    GTP command reference.
                                                             (line 1131)
* reset_connection_node_counter:         GTP command reference.
                                                             (line  836)
* reset_life_node_counter:               GTP command reference.
                                                             (line  766)
* reset_owl_node_counter:                GTP command reference.
                                                             (line  788)
* reset_reading_node_counter:            GTP command reference.
                                                             (line  804)
* reset_search_mask:                     GTP command reference.
                                                             (line 1189)
* reset_trymove_counter:                 GTP command reference.
                                                             (line  820)
* restricted_genmove:                    GTP command reference.
                                                             (line  640)
* return codes:                          Reading Basics.     (line   51)
* same_dragon:                           GTP command reference.
                                                             (line  544)
* scoring:                               Scoring.            (line    6)
* semeai:                                Dragons.            (line  254)
* semeai_attack_certain:                 Dragons.            (line  254)
* semeai_attack_point:                   Dragons.            (line  254)
* semeai_defense_certain:                Dragons.            (line  254)
* semeai_defense_point:                  Dragons.            (line  254)
* set_free_handicap:                     GTP command reference.
                                                             (line  180)
* set_random_seed:                       GTP command reference.
                                                             (line 1148)
* set_search_diamond:                    GTP command reference.
                                                             (line 1181)
* set_search_limit:                      GTP command reference.
                                                             (line 1205)
* SGF (Smart Game Format):               SGF Support.        (line    6)
* SGF files in memory:                   SGF.                (line    6)
* shape attributes:                      Pattern Classification.
                                                             (line    6)
* showboard:                             GTP command reference.
                                                             (line  876)
* Smart Game Format:                     SGF Support.        (line    6)
* Speedup of reading process:            Hashing.            (line    6)
* start_sgftrace:                        GTP command reference.
                                                             (line 1055)
* string:                                Worms and Dragons.  (line   27)
* superstring:                           General Utilities.  (line  249)
* surround:                              Dragons.            (line  238)
* surround_map:                          GTP command reference.
                                                             (line 1172)
* surround_size:                         Dragons.            (line  238)
* surround_status:                       Dragons.            (line  238)
* symmetry and transformations:          Symmetry & transformations.
                                                             (line    6)
* symmetry and transformations of shapes: Symmetry & transformations.
                                                             (line    6)
* tactical_analyze_semeai:               GTP command reference.
                                                             (line  478)
* teaching josekis to GNU Go:            Joseki Compiler.    (line    6)
* territory:                             Territory and Moyo. (line    6)
* test_eyeshape:                         GTP command reference.
                                                             (line  852)
* The Go Modem Protocol and Go Text Protocol: GMP and GTP.   (line    6)
* the joseki compiler:                   Joseki Compiler.    (line    6)
* time_left:                             GTP command reference.
                                                             (line  699)
* time_settings:                         GTP command reference.
                                                             (line  689)
* timers:                                General Utilities.  (line  328)
* traces:                                Traces.             (line    6)
* Transposition table:                   Hashing.            (line    6)
* Trying hypothetical moves:             Tactical Reading.   (line    6)
* tryko:                                 GTP command reference.
                                                             (line  311)
* trymove:                               GTP command reference.
                                                             (line  303)
* tune_move_ordering:                    GTP command reference.
                                                             (line 1086)
* tuning GNU Go:                         Traces.             (line    6)
* tuning the pattern database:           Tuning.             (line    6)
* tuning the shapes database:            Tuning.             (line    6)
* unconditional_status:                  GTP command reference.
                                                             (line  552)
* undo:                                  GTP command reference.
                                                             (line  671)
* Usage of the stack in reading:         Tactical Reading.   (line    6)
* version:                               GTP command reference.
                                                             (line   58)
* weakness:                              Dragons.            (line  199)
* worm <1>:                              Worms.              (line    6)
* worm:                                  Worms and Dragons.  (line   27)
* worm_cutstone:                         GTP command reference.
                                                             (line 1015)
* worm_data:                             GTP command reference.
                                                             (line  970)
* worm_stones:                           GTP command reference.
                                                             (line 1007)
* Zobrist hashing algorithm:             Hashing.            (line    6)


File: gnugo.info,  Node: Functions Index,  Prev: Concept Index,  Up: Top

Functions Index
***************

 [index ]
* Menu:

* abortgo:                               Print Utilities.     (line  60)
* accuratelib:                           Board Utilities.     (line 127)
* add_eyevalues:                         Eye Functions.       (line 199)
* add_false_eye:                         Eye Functions.       (line 107)
* add_stone:                             Board Utilities.     (line  25)
* adjacent_strings:                      Board Utilities.     (line 237)
* amalgamate_most_valuable_helper:       Connection.          (line  24)
* analyze_eyegraph:                      Eye Functions.       (line 214)
* approxlib:                             Board Utilities.     (line 113)
* atari_atari <1>:                       Combinations.        (line  52)
* atari_atari <2>:                       Combination Attacks. (line   6)
* atari_atari:                           Move Generators.     (line  72)
* atari_atari_blunder_size:              Combinations.        (line  70)
* atari_atari_confirm_safety:            Combinations.        (line  60)
* attack:                                Reading Basics.      (line 122)
* block_off:                             Break Ins.           (line  20)
* blunder_size:                          General Utilities.   (line 174)
* break_in:                              Break Ins.           (line  14)
* chainlinks:                            Board Utilities.     (line 177)
* chainlinks2:                           Board Utilities.     (line 183)
* chainlinks3:                           Board Utilities.     (line 189)
* change_dragon_status:                  General Utilities.   (line   9)
* clear_board:                           Board Utilities.     (line  17)
* color_to_string:                       Print Utilities.     (line  64)
* combinations:                          Combinations.        (line  45)
* compute_escape:                        Dragons.             (line 207)
* compute_eyes:                          Eye Functions.       (line  86)
* compute_eyes_pessimistic <1>:          The Owl Code.        (line  42)
* compute_eyes_pessimistic:              Eye Functions.       (line  99)
* compute_influence:                     Influence Utilities. (line  12)
* compute_surrounding_moyo_sizes:        Dragons.             (line 169)
* confirm_safety:                        General Utilities.   (line 168)
* count_common_libs:                     Board Utilities.     (line 148)
* countlib:                              Board Utilities.     (line  85)
* countstones:                           Board Utilities.     (line 167)
* cut_connect_callback:                  Connection Functions.
                                                              (line   9)
* DEBUG:                                 Print Utilities.     (line  54)
* decrease_depth_values:                 General Utilities.   (line 153)
* defend_against:                        General Utilities.   (line  13)
* disconnect:                            Connection Reading.  (line  16)
* does_attack:                           General Utilities.   (line  25)
* does_capture_something:                Board Utilities.     (line 259)
* does_defend:                           General Utilities.   (line  31)
* double_atari:                          General Utilities.   (line 190)
* dragon_eye:                            Amalgamation.        (line  28)
* draw_letter_coordinates:               Print Utilities.     (line  87)
* dump_stack:                            Board Utilities.     (line  21)
* edge_distance:                         Board Utilities.     (line  64)
* endgame_shapes:                        Move Generators.     (line  86)
* estimate_territorial_value:            Territorial value.   (line   6)
* extended_chainlinks:                   Board Utilities.     (line 196)
* eyevalue_to_string:                    Eye Functions.       (line 204)
* fastlib:                               Board Utilities.     (line  99)
* fill_liberty:                          Move Generators.     (line 100)
* find_common_libs:                      Board Utilities.     (line 152)
* find_connections:                      Connection Functions.
                                                              (line  25)
* find_cuts <1>:                         Connection Functions.
                                                              (line  17)
* find_cuts:                             Worms.               (line 152)
* find_defense:                          Reading Basics.      (line 131)
* find_eye_dragons:                      Eye Functions.       (line  78)
* find_half_and_false_eyes:              Eye Functions.       (line 136)
* find_neighbor_dragons:                 Dragons.             (line 145)
* find_origin:                           Board Utilities.     (line 204)
* find_proper_superstring_liberties:     General Utilities.   (line 290)
* find_superstring:                      General Utilities.   (line 249)
* find_superstring_liberties:            General Utilities.   (line 280)
* find_superstring_stones_and_liberties: General Utilities.   (line 301)
* findlib:                               Board Utilities.     (line  90)
* findstones:                            Board Utilities.     (line 171)
* followup:                              Pattern Values.      (line  34)
* fuseki:                                Move Generators.     (line  43)
* gameinfo_clear:                        Positional Functions.
                                                              (line 172)
* gameinfo_load_sgfheader:               Positional Functions.
                                                              (line 180)
* gameinfo_play_move:                    Positional Functions.
                                                              (line 185)
* gameinfo_play_sgftree:                 Positional Functions.
                                                              (line 202)
* gameinfo_play_sgftree_rot:             Positional Functions.
                                                              (line 191)
* gameinfo_print:                        Positional Functions.
                                                              (line 176)
* get_kom_pos:                           Board Utilities.     (line  74)
* get_komaster:                          Board Utilities.     (line  72)
* gfprintf:                              Print Utilities.     (line  41)
* gnugo_add_stone:                       Positional Functions.
                                                              (line  24)
* gnugo_attack:                          Positional Functions.
                                                              (line  83)
* gnugo_clear_board:                     Positional Functions.
                                                              (line  16)
* gnugo_estimate_score:                  Positional Functions.
                                                              (line  95)
* gnugo_examine_position:                Positional Functions.
                                                              (line 103)
* gnugo_find_defense:                    Positional Functions.
                                                              (line  87)
* gnugo_genmove:                         Positional Functions.
                                                              (line  79)
* gnugo_get_board:                       Positional Functions.
                                                              (line 111)
* gnugo_get_boardsize:                   Positional Functions.
                                                              (line 115)
* gnugo_get_komi:                        Positional Functions.
                                                              (line 107)
* gnugo_get_move_number:                 Positional Functions.
                                                              (line 119)
* gnugo_is_legal:                        Positional Functions.
                                                              (line  57)
* gnugo_is_pass:                         Positional Functions.
                                                              (line  32)
* gnugo_is_suicide:                      Positional Functions.
                                                              (line  61)
* gnugo_placehand:                       Positional Functions.
                                                              (line  65)
* gnugo_play_move:                       Positional Functions.
                                                              (line  36)
* gnugo_play_sgfnode:                    Positional Functions.
                                                              (line  45)
* gnugo_play_sgftree:                    Positional Functions.
                                                              (line  52)
* gnugo_recordboard:                     Positional Functions.
                                                              (line  70)
* gnugo_remove_stone:                    Positional Functions.
                                                              (line  28)
* gnugo_set_komi:                        Positional Functions.
                                                              (line  20)
* gnugo_sethand:                         Positional Functions.
                                                              (line  74)
* gnugo_undo_move:                       Positional Functions.
                                                              (line  40)
* gnugo_who_wins:                        Positional Functions.
                                                              (line  91)
* gprintf:                               Print Utilities.     (line  45)
* has_neighbor:                          Board Utilities.     (line 229)
* hashnode_new_result:                   Hash Organization.   (line  52)
* hashtable_enter_position:              Hash Organization.   (line  47)
* hashtable_search:                      Hash Organization.   (line  43)
* have_common_lib:                       Board Utilities.     (line 161)
* increase_depth_values:                 General Utilities.   (line 149)
* influence_mark_non_territory:          Influence Utilities. (line  35)
* init_gnugo <1>:                        Positional Functions.
                                                              (line  11)
* init_gnugo:                            Getting Started.     (line  13)
* is_corner_vertex:                      Board Utilities.     (line  68)
* is_edge_vertex:                        Board Utilities.     (line  60)
* is_eye_space:                          Eye Functions.       (line 113)
* is_false_eye:                          Eye Functions.       (line 129)
* is_halfeye:                            Eye Functions.       (line 129)
* is_hoshi_point:                        Print Utilities.     (line  84)
* is_illegal_ko_capture:                 Board Utilities.     (line  55)
* is_ko:                                 Board Utilities.     (line 241)
* is_ko_point:                           Board Utilities.     (line 253)
* is_legal <1>:                          Board Utilities.     (line  39)
* is_legal:                              Roadmap.             (line  47)
* is_marginal_eye_space:                 Eye Functions.       (line 129)
* is_pass:                               Board Utilities.     (line  35)
* is_proper_eye_space:                   Eye Functions.       (line 113)
* is_self_atari:                         Board Utilities.     (line 210)
* is_suicide:                            Board Utilities.     (line  43)
* komaster_trymove:                      Some Board Functions.
                                                              (line  65)
* liberty_of_string:                     Board Utilities.     (line 216)
* location_to_buffer:                    Print Utilities.     (line  72)
* location_to_string:                    Print Utilities.     (line  68)
* make_domains <1>:                      Eye Functions.       (line  59)
* make_domains:                          Worms.               (line 152)
* mark_string:                           Board Utilities.     (line 264)
* max_eye_threat:                        Eye Functions.       (line 193)
* max_eye_value:                         Eye Functions.       (line 118)
* max_eyes:                              Eye Functions.       (line 188)
* maxterri:                              Pattern Values.      (line  18)
* maxvalue:                              Pattern Values.      (line  26)
* min_eye_threat:                        Eye Functions.       (line 178)
* min_eyes:                              Eye Functions.       (line 183)
* minterri:                              Pattern Values.      (line  14)
* minvalue:                              Pattern Values.      (line  26)
* modify_depth_values:                   General Utilities.   (line 140)
* modify_eye_spaces1:                    Connection Functions.
                                                              (line  33)
* move_in_stack:                         Board Utilities.     (line 273)
* mprintf:                               Print Utilities.     (line  50)
* neighbor_of_string:                    Board Utilities.     (line 225)
* obvious_false_eye:                     Eye Functions.       (line 159)
* OTHER_COLOR:                           Basic Data Structures.
                                                              (line  18)
* owl_attack:                            The Owl Code.        (line  42)
* owl_defend:                            The Owl Code.        (line  42)
* owl_reasons <1>:                       Owl attack and defense.
                                                              (line   6)
* owl_reasons:                           Move Generators.     (line  24)
* partition_eyespaces:                   Eye Functions.       (line  67)
* play_attack_defend2_n:                 General Utilities.   (line  82)
* play_attack_defend_n:                  General Utilities.   (line  82)
* play_break_through_n:                  General Utilities.   (line  61)
* play_connect_n:                        General Utilities.   (line 106)
* play_move:                             Some Board Functions.
                                                              (line  79)
* popgo <1>:                             Some Board Functions.
                                                              (line  53)
* popgo:                                 Roadmap.             (line  47)
* propagate_eye:                         Eye Functions.       (line  72)
* proper_superstring_chainlingks:        General Utilities.   (line 320)
* purge_persistent_breakin_cache:        Persistent Cache.    (line   6)
* purge_persistent_connection_cache:     Persistent Cache.    (line   6)
* purge_persistent_owl_cache:            Persistent Cache.    (line   6)
* purge_persistent_reading_cache:        Persistent Cache.    (line   6)
* remove_stone:                          Board Utilities.     (line  30)
* restore_board:                         Board Utilities.     (line  13)
* restore_depth_values:                  General Utilities.   (line 157)
* result_to_string:                      Print Utilities.     (line 115)
* revise_semeai:                         Move Generators.     (line  93)
* revise_thrashing_dragon:               Move Generators.     (line  77)
* safe_move:                             Reading Basics.      (line 140)
* safety_to_string:                      Print Utilities.     (line 111)
* same_string:                           Board Utilities.     (line 233)
* search_persistent_reading_cache:       Persistent Cache.    (line   6)
* second_order_liberty_of_string:        Board Utilities.     (line 220)
* semeai:                                Move Generators.     (line  31)
* set_depth_values:                      General Utilities.   (line 121)
* set_eyevalue:                          Eye Functions.       (line 167)
* shape:                                 Pattern Values.      (line  30)
* shapes:                                Move Generators.     (line  48)
* shapes_callback:                       Patterns Overview.   (line  59)
* showboard:                             Print Utilities.     (line  98)
* simple_showboard:                      Print Utilities.     (line  90)
* small_semeai:                          Reading Basics.      (line  91)
* somewhere:                             General Utilities.   (line  37)
* start_timer:                           General Utilities.   (line 328)
* status_to_string:                      Print Utilities.     (line 107)
* stones_on_board:                       Board Utilities.     (line 278)
* store_board:                           Board Utilities.     (line   9)
* store_persistent_reading_cache:        Persistent Cache.    (line   6)
* string_connect:                        Connection Reading.  (line  12)
* string_to_location:                    Print Utilities.     (line  76)
* superstring_chainlinks:                General Utilities.   (line 311)
* terri:                                 Pattern Values.      (line  10)
* test_eyeshape:                         Eye Functions.       (line 210)
* test_symmetry_after_move:              General Utilities.   (line  52)
* time_report:                           General Utilities.   (line 334)
* topological_eye:                       Eye Functions.       (line 143)
* tryko:                                 Some Board Functions.
                                                              (line  43)
* trymove <1>:                           Some Board Functions.
                                                              (line  31)
* trymove:                               Roadmap.             (line  47)
* unconditional_life <1>:                General Utilities.   (line 204)
* unconditional_life:                    Worms.               (line 175)
* undo_move:                             Some Board Functions.
                                                              (line  98)
* value:                                 Pattern Values.      (line  22)
* value_move_reasons():                  Valuation.           (line   6)
* whose_area:                            Influence Utilities. (line  51)
* whose_moyo:                            Influence Utilities. (line  45)
* whose_territory:                       Influence Utilities. (line  40)
* worm_reasons:                          Move Generators.     (line  19)


